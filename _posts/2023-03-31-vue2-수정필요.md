---
title: Vue
tags: vue javascript
---

```js

Vue
	.createApp({
		data() {
			return {
				test: "hello",
				list: [
					{ id: 1, name: "아메리카노", price: 5000 },
					{ id: 2, name: "카페라떼", price: 5500 },
					{ id: 3, name: "카페모카", price: 5500 }
				],
				isShowRegForm: true,
				menu: { name: "", price: 0 }
				// menu의 name과 price는 html에서 v-model="menu.name"와 v-model="menu.price"로 인해 2 way 바인딩 상태이다.
			};
		},
		methods: {
			categoryClickHandler(e) {
				this.list.push({ id: 4, name: "디카페인 아메리카노", price: 5500 })
				//	카테고리 클릭시 list에 메뉴 하나 추가
			},
			addMenuHandler() {
				this.isShowRegForm = !this.isShowRegForm;
				// html에서 :class="{'d-none':isShowRegForm}"을 넣었다. :class는 v-bind:class의 축약
				// 변수 isShowRegForm이 true면 d-none를 추가 false면 d-none를 추가하지 않는다
			},
			menuSaveHandler() {
				var myHeaders = new Headers();
				myHeaders.append("Content-Type", "application/json");

				var raw = JSON.stringify(this.menu);

				var requestOptions = {
					method: 'POST',
					headers: myHeaders,
					body: raw,
					redirect: 'follow'
				};

				fetch("http://localhost:8080/menus", requestOptions)
					.then(response => response.text())
					.then(result => console.log(result))
					.catch(error => console.log('error', error));
				//	fetch를 하는 순간 데이터를 요청하고 올 때 까지 기다린다.
				//	응답이 오면 than 메소드를 실행한다. 하지만 응답온 데이터는 가공안된 생 데이터 이다.
				//	생 데이터를 text로 뽑아 올 때 I/O 작업이 필요하다. 비동기 필요 그래서 두 번째 than이 있는 것
			},
			load() {
				fetch("/menus")
					.then(res => {
						return res.json();
					})
					.then(list => {
						this.list = list;
						//	위 data()에 있던 기존 list는 사라지고 /menus 요청으로 가져온 list로 대체됨
						//	여기서 this는 Vue가 가로채서 만들어준 Proxy다
					})
			}
		},
		beforeCreate() {
			console.log("beforeCreate")
		},
		created() {
			console.log("created")
		},
		beforeMount() {
			console.log("beforeMount");
		},
		mounted() {
			console.log("mounted")
			//	Vue가 DOM에 붙어 화면에 보일 수 있는 상태가 mounted다
			//	페이지를 가져오기 전 데이터를 준비하는 것이 아닌 데이터를 가져오고 바로 보여줘야 되므로 데이터를 가져오는 위치는 mount가 가장 적절하다
			this.load();
			//	여기서 this는 Vue가 가로채서 만들어준 Proxy다
		},
		beforeUpdate() { console.log("beforeUpdate") },
		updated() { console.log("updated") },
		beforeUnmount() { console.log("beforeUnmount") },
		unmounted() { console.log("unmounted") }

	})
	.mount("#main-section");

```