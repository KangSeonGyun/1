---
title: Spring DI
tags: spring
---

### Spring 소개

Java SE(Standard Edition) + Java EE(Enterprise Edition) or Spring   
Java SE - 일반적인 로컬 응용 프로그램 개발을 위한 API (파일 I/O, 콘솔I/O, 원도우  I/O, 네트워크  I/O, Thread...)   
Java EE or Spring - 분산형, 기업형 응용 프로그램 개발을 위한 API (결합력을 낮추는 DI, DB, transaction처리, 로그 처리...)

기업형 어플리케이션 레이어
UI → Service → Dao → DB

```java
private Dao1 dao = new Dao1();
```

해당 코드는 Service의 멤버 부분이다. Service가 Dao를 바꿔끼리면 Service의 소스 코드를 수정해야 하며 이것은 결합력이 높은 예시다.   
소스 코드를 수정하기 않고 객체를 바꿔끼기 위해 참조 자료형은 interface형으로 써야하며 인터페이스를 구현하고 있는 객체 생성과 조립은 외부(XML, Annotation)에서 한다. Service와 Dao를 결합(DI)시키는 작업은 UI가 한다.   
또한 Service와 Dao로 Layer를 나눴을 때 JDBC Connection이 끊어지는 함수들을 묶어서 하나의 transaction으로 관리해야 하는 경우가 생기지만 나눠진 함수들은 Connection을 공유하기 힘들다.

Spring이 Library만 사용하는 방식으로 transaction management를 깔끔하게 처리하며 **객체 생성과 조립**, 설정파일과 DI를 구현하기 쉽게 해줌으로써 모듈결합이 쉬워졌다.   
Java EE도 쉽게 사용할 수 있으나 유로화 되었고 개발자들이 무료인 Spring에 적응한 상태이다.

### DI(종속성 주입, 부품조립)

A제품에 B부품(Dependency)이 있을 경우 A와 B를 조립(Injection)하는 것을 DI라 한다.   
기업형 어플리케이션은 부품(Dependency)을 갈아 끼거나 업데이트해야 한다. 따라서 Composition has a(일체형)가 아닌 Association has a(조립형)와 같이 구현해야 한다.

```java
// Composition has a
A a = new A();

// A가 생성될 때 A의 생성자에서 B를 결합하므로 부품 교체가 힘들다
// 사용자가 부품 B의 존재를 알 수 없다
```
```java
// Association has a
B b = new B();
A a = new A();

a.set(b);
```

조립(Injection)의 방법은 Setter Injection(조립형)과 Construction Injection(조립형)이 있다.

**Setter Injection**

```java
B b = new B();
A a = new A();

a.set(b);
```
**Construction Injection**

```java
B b = new B();
A a = new A(b);
```

### IoC(Inversion of Control) 컨테이너 (Dependency 컨테이너, 부품 컨테이너)

주문서(XML, Annotation)를 이용해 여러가지 부품들을 입력하고 Spring에 제공한다. Spring은 우리가 제공한 주문서대로 부품을 생성해서 IoC 컨테이너에 담아두고 조립, 생성한다. IoC 컨테이너는 부품끼리 조립해서 담아둘 수도 있다.   
Inversion(역순)이 붙은 이유는 일체형과 조립형의 DI순서를 생각해보면 이유를 알 수 있다. 일체형은 제품 A가 부품 B를 생성하지만 조립형은 부품 B가 먼저 만들어지고 제품 A와 결합한다. 즉, 부품끼리 먼저 결합한다.   
IoC 컨테이너가 부품만 담고 있었다면 Dependency 컨테이너라고 불렸겠지만 Dependency가 조립까지되서 담겨지므로 IoC 컨테이너로 불린다.

Program.java
-------------

```java

package kr.co.rland.web.di;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;
import kr.co.rland.web.service.MenuService;

// DI(Dependency Injection)는 부품 결합이다
// A가 B를 사용하긴 하지만 같이 태어나진 않는다
// 따라서 DI

public class Program {

	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("kr/co/rland/web/di/context.xml");
//		서블릿 저장소가 아닌 IoC컨테이너다
//		ClassPath의 루트는 src/main/java 다
		
		MenuRepository menuRepository = context.getBean(MenuRepository.class);
		
		List<Menu> list = menuRepository.findAll();
		
		System.out.println(list);
		
//		-----------------------------------------------------------------------
		
		MenuService service = context.getBean(MenuService.class);
		
		List<Menu> list2 = service.getList();
		
		System.out.println(list2);
	}

}


```

context.xml
-------------

```xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 지시서 작성 / 컨테이너에 담기 / 객체로 만들어 준다 -->
    <!-- bean definitions here -->
	<bean name="repository" class="kr.co.rland.web.repository.jdbc.JdbcMenuRepository"></bean>
	<bean class="kr.co.rland.web.service.DefaultMenuService">
		<property name="repository" ref="repository"></property>
		<!-- property의 name은 Member가 아닌 Setter를 찾는다 -->
		<!-- property 서비스와 레포지토리 객체 관계를 설정하여 조립까지 가능 -->
	</bean>
</beans>

```

JdbcMenuRepositoryTest.java
-------------

```java

package kr.co.rland.web.repository.jdbc;

import java.util.List;

import org.junit.jupiter.api.Test;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

class JdbcMenuRepositoryTest {

	@Test
	void testFindAll() {
		MenuRepository repository = new JdbcMenuRepository();
		List<Menu> list = repository.findAll();

		System.out.println(list.size());

	}

}

```

Menu.java
-------------

```java

package kr.co.rland.web.entity;

import java.util.Date;

public class Menu {
	private long id;
	private String name;
	private int price;
	private Date regDate;
	private int categoryId;
	private long regMemberId;

	public Menu(String name, int price, int categoryId) {
		this.name = name;
		this.price = price;
		this.categoryId = categoryId;
	}

	public Menu(long id, String name, int price, Date regDate, int categoryId, long regMemberId) {
		this.id = id;
		this.name = name;
		this.price = price;
		this.regDate = regDate;
		this.categoryId = categoryId;
		this.regMemberId = regMemberId;
	}

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getPrice() {
		return price;
	}

	public void setPrice(int price) {
		this.price = price;
	}

	public Date getRegDate() {
		return regDate;
	}

	public void setRegDate(Date regDate) {
		this.regDate = regDate;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public long getRegMemberId() {
		return regMemberId;
	}

	public void setRegMemberId(long regMemberId) {
		this.regMemberId = regMemberId;
	}

	@Override
	public String toString() {
		return "Menu [id=" + id + ", name=" + name + ", price=" + price + ", regDate=" + regDate + ", categoryId="
				+ categoryId + ", regMemberId=" + regMemberId + "]";
	}

}

```