---
title: 1way 2way
tags: javascript
---

```html

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="./calc2.js" defer="defer"></script>
</head>
<body>
	<section id="calc">
		<h1>덧셈 계산기{{x}}</h1>
		<form>
			<fieldset>
				<legend>계산기 입력폼</legend>
				<div>
					<label>x:</label>
					<input dir="rtl" v-model.trim.number="x" @input="calcHandler"> 
					<label>y:</label>
					<input dir="rtl" v-model.trim.number="y" @input="calcHandler">
					<span>=</span>
					<span v-text="z"></span>
				</div>
				<hr>
				<div>
					<input type="submit" value="초기화" @click.prevent="resetHandler">
					<input type="submit" value="계산하기" @click.prevent="calcHandler">
				</div>
			</fieldset>
		</form>
	</section>
</body>
</html>

```

```js

window.addEventListener("load", function() {
	const inputs = document.querySelectorAll("input");
	const xInput = inputs[0];
	const yInput = inputs[1];
	const resetButton = inputs[2];
	const submitButton = inputs[3];
	
	const resultSpan = document.querySelector("form span:last-child");
	resetButton.onclick = (e) => {
		e.preventDefault();
		xInput.value = 0;
		yInput.value = 0;
		console.log(e);
	};
	// 1way binding
	submitButton.onclick = (e) => {
		e.preventDefault();
		let x = parseInt(xInput.value);
		let y = parseInt(yInput.value);
		let result = x + y;
		resultSpan.innerText = result;
		console.log(e);
	};
	// 2way binding
	xInput.oninput = (e) => {
		let x = parseInt(xInput.value);
		let y = parseInt(yInput.value);
		let result = x + y;
		resultSpan.innerText = result;
	};
	yInput.oninput = (e) => {
		let x = parseInt(xInput.value);
		let y = parseInt(yInput.value);
		let result = x + y;
		resultSpan.innerText = result;
	};
});

```

js ES6가 햇갈린다..

```js

var x = 30;
console.log(window.x);

var f1 = function () {
    console.log(this);
}

f1();

// 모든 function은 this를 갖고있다

// script의 type이 없으면 console.log엔 30과 window가 나온다

// js 첫 줄에 "use strict";를 적으면 strict mode(엄격한 모드)로 실행되며 console.log엔 30과 undefined가 뜬다

// script의 type이 module이면 해당 scrpit의 js 공간은 전역공간이 아닌 모듈공간이 된다.
// script의 type이 module이면 strict mode(엄격한 모드)로 실행되며 console.log엔 undefined가 2개 뜬다

// 이 다음 코드부터는 module type이다

var obj = { x, f1 };

obj.f1(); // {x: 30, f1: ƒ}

f1(); // undefined

f1.call(obj); // {x: 30, f1: ƒ}

// ---------------------------------

function add({ x, y }) {
    return x + y;
}

var values = { x: 20, y: 30 }

add(values);

// add 함수는 x와 y를 갖고있는 객체를 받아 디스트럭쳐링 한다

// ---------------------------------

// 문제
// methods의 print()를 이용하며 this를 d(data) 옮겨 
// .print로 hello를 출력하고 싶다

function createApp({ data, methods }) {
    let d = data();
    // d엔 {test: 'hello'} 가 저장된다

    methods.thisPrint(); // {thisPrint: ƒ, testPrint: ƒ}
    // 호출자가 methods이므로 this를 찍어보면 methods 그 자체가 나온다

    methods.testPrint(); // undefined
    // 호출자 methods에는 test가 없다

    methods.thisPrint.call(d); // {test: 'hello'}
    // call로 인해 호출자가 d로 바뀌었다. d 그 자체가 출력된다

    methods.testPrint.call(d); // hello
    // call로 인해 호출자가 d로 바뀌었다. d의 test의 값 hello가 출력된다

    // -----------------------------



};

createApp({
    data() {
        return { test: "hello" }
    },
    methods: {
        thisPrint() {
            console.log(this);
        },
        testPrint() {
            console.log(this.test);
        }
    }

})

```