---
title: DB
tags: db
---

## SQL - DBMS(Database + Management System)에게 구조화된 데이터를 질의하는 명령어
* DDL - create/alter/drop
* DML - select/insert/update/delete **DML 쿼리문 외우기**
* DCL - grant/revoke

## Database
* 무결성 / 중복을 없애는 방법으로 결함을 줄임
* Relational DBMS
* 관계형 참조

### Database의 단점
* 동시성 - 같은 Data를 동시에 작업해 병목현상이 발생한다
* 성능 - 여러명이 사용함으로 기다림이 생길 수 있다
* 보안 - Network를 통해 연결되어 있는 상태를 기반으로 함
* 따라서 관리자(Program)를 통해 Data를 관리한다
* 다른사람이 작업 중인 데이터(SELECT 제외)는 COMMIT or ROLLBACK 전까진 데이터를 다룰 수 없다.

## VALUE TYPE
* Character 형식 'A', '123' / ""는 다른의미로 사용된다
* CHAR(3) / 영어는 1byte 아시아권 글자들은 2byte 즉, 영어는 3글자 아시아권은 1.5글자만 입력 가능하다 / 공간의 길이가 고정적이다
* NCHAR(3) / 영어 3글자 아시아권 글자들도 3글자
* VARCHAR2(100) (베어케어2) / 100byte / 공간의 길이가 가변적이다 3byte만 쓴다면 나머지 공간을 돌려줌
* LONG
* CLOB / 한 칼럼에만 가능하다 / LONG을 대체한다
* NCLOB
* NAME의 자료형이 CHAR, VARCHAR2라면 한 글자에 영어 1byte, 아시아권 글자 2byte
* 비영어권에서 NCHAR, NVARCHAR2를 이용하는 것이 바람직하다 / 한 글자에 영어 2byte, 아시아권 글자 2byte

### Numeric 형식
-- NUMBER

### Date 형식
* DATE / 년, 월, 일 / 시, 분, 초는 들어가지 않는다
* TIMESTAMP / 시간까지 포함


## 테이블 정의하기 = 데이터 구조 정의하기 = 개념상의 데이터 정의하기 = Entity 정의하기

* 예약어를 테이블명으로 쓰고싶은 경우 ""를 붙여 "TABLE명"으로 사용 가능하다

```sql
CREATE TABLE NOTICE2700
(
ID NUMBER,
TITLE NVARCHAR2, -- 한국에서 운용하므로 NVARCHAR2으로 했다.
WRITER_ID NVARCHAR2,
CONTENT NCLOB,
REGDATE TIMESTAMP,
HIT NUMBER,
FILES VARCHAR2 -- 파일은 디스크에 저장하고 경로만 저장한다 / 그래서 NCLOB이 아니라 (영어로 파일명을 쓰므로)VARCHAR이다
);
```

* 파일 스토리지
브라우저가 파일을 요청할 때 A 웹서버엔 파일이 있고 B 웹서버엔 파일이 없을 수 있다.   
웹서버가 여러개일 경우 웹서버에 파일을 저장하지 않고 파일 스토리지에 보관한다

## DML

* INSERT INTO MEMBER2700(ID, NAME) VALUES(1, '가나다');

* SELECT LENGTHB(NAME) FROM MEMBER2700;

* UPDATE MEMBER SET NAME='ㅇㅇ', EMAIL='ㅇㅇ@ㅇㅇ.ㅇㅇ' WHERE ID=25;

* DELETE MEMBER WHERE NICNAME='k';

## DML 응용

* 원하는 컬럼만 원하는 순서대로 조회하기
SELECT ID, NAME, PWD FROM MEMBER;

* ID 컬럼을 USER_ID로 표시, PWD 컬럼을 PASSWORD로 표시 / AS가 없어도 된다
SELECT ID AS USER_ID, PWD AS PASSWORD FROM MEMBER;
SELECT ID USER_ID, PWD PASSWORD FROM MEMBER;

-- 2/1

-- 산술 연산자
SELECT ID+3 ID FROM MEMBER WHERE ID=1;
-- MEMBER의 ID에 3을 더해서 조회
-- 별칭 ID(ID+3)열에 4가 출력된다 

SELECT 3+4 FROM MEMBER;
-- MEMBER테이블의 레코드 수만큼 7이 나온다

SELECT 3+4 FROM DUAL;
-- DUAL - 연산자를 테스트 해볼 때 더미 테이블
-- 3+4열에 7이 출력된다

SELECT '3'+4 SUM FROM DUAL;
-- 별칭 SUM('3'+4)열에 7이 출력된다

SELECT '3'||10 SUM FROM DUAL;
-- 별칭 SUM('3'||10)열에 310이 출력된다
-- || 문자열 더하기 연산자

SELECT name || '(' || id || ')' FROM MEMBER;
-- MEMBER테이블에서 모든 회원의 name, id Column조회 / name(id) 형식으로 출력

--------------------------------------------------------------------------------
-- 비교 연산자
-- = 같다 / != 같지 않다 / ^= ORACLE의 같지 않다 / <> ANSI의 같지 않다
-- >, <, >=, <=, IS NULL, IS NOT NULL
-- ANSI C, SQL 등.. 표준

SELECT * FROM MEMBER WHERE NAME IS NULL;
-- MEMBER테이블에서 NAME이 NULL인 모든 Column조회 / IS는 NULL만 비교할 수있다

SELECT * FROM MEMBER WHERE NAME IS NOT NULL;
-- MEMBER테이블에서 NAME이 NULL이 아닌 모든 Column조회

--------------------------------------------------------------------------------

-- 관계 연산자
-- NOT, AND, OR, BETWEEN, IN

SELECT * FROM MEMBER WHERE ID=0 OR ID=1 OR ID=2;
SELECT * FROM MEMBER WHERE 0 <= ID AND ID<=2;
SELECT * FROM MEMBER WHERE ID BETWEEN 0 AND 2;
-- MEMBER테이블에서 ID Column(열)의 값이 0, 1, 2(연속된 데이터)인 모든 Column조회

SELECT * FROM MEMBER WHERE ID IN(11, 19, 24);
-- MEMBER테이블에서 ID Column(열)의 값이 11, 19, 24인 모든 Column조회

SELECT * FROM MEMBER WHERE ID NOT IN(11, 19, 24);
-- MEMBER테이블에서 ID Column(열)의 값이 11, 19, 24가 아닌 모든 Column조회

--------------------------------------------------------------------------------

-- 패턴 비교 연산자
-- LIKE를 쓸 때 %, _ 기호를 사용할 수 있다
SELECT * FROM MEMBER WHERE NAME LIKE '강%';
-- MEMBER테이블에서 NAME이 '강'으로 시작하는 모든 Column조회

SELECT * FROM MEMBER WHERE NAME LIKE '%강%';
-- MEMBER테이블에서 NAME에 '강'이 포함된 모든 Column조회

SELECT * FROM MEMBER WHERE NAME LIKE '_강';
-- MEMBER테이블에서 NAME에 '강' 앞에 한 글자와 '강'이 포함된 모든 Column조회

SELECT * FROM MEMBER WHERE NAME LIKE '__강';
-- MEMBER테이블에서 NAME에 '강' 앞에 두 글자와 '강'이 포함된 모든 Column조회

--------------------------------------------------------------------------------

-- 2/2
-- 정규식(regular expression - regex or regexp)
-- 검색 패턴을 형성하는 문자열

-- [] 정규식의 글자수 제한 방법

-- 전화번호
-- 010-[0123456789][0-9]\d\d-\d{4}
-- ^01[01689]-\d{3,4}-\d{4}$ / ^ 시작 / $ 끝 / 정규식 양 옆에 다른 글자가 오면 안 된다

-- url / new@lect.com
-- ...@.....(com|org|org) / 3글자@4글자.(com|org|org) / 글자수 고정

-- 2/3
-- SQL Function for Regular Expressions
-- REGEXP_LIKE
SELECT * FROM MEMBER WHERE REGEXP_LIKE(NAME, '^.*강.*$');
-- . / 줄 종결 자 ( , 또는 ) 를 제외한 모든 단일 문자
-- * / 바로앞 글자를 0회 이상 일치시킵니다.
-- MEMBER테이블에서 NAME에 강이 포함된 모든 Column조회

SELECT ROWNUM, MEMBER.* FROM MEMBER WHERE ROWNUM BETWEEN 1 AND 5;
-- MEMBER테이블에서 ROWNUM의 값이 1 ~ 5인 ROWNUM와 MEMBER테이블의 모든 Column조회

SELECT ROWNUM, MEMBER.* FROM MEMBER WHERE ROWNUM >= 2;
-- ROWNUM이 테이블의 Column으로 미리 값이 있지 않다면 아무것도 조회되지 않는다
-- ROWNUM은 조건 WHERE ROWNUM >= 2에 맞을 때 한 줄 한 줄 쌓이기 때문

SELECT * FROM (SELECT * FROM MEMBER);
-- FROM 뒤에는 꼭 테이블명이 아닌 격자형태의 데이터가 오면 된다 / SUBQUERY

SELECT * FROM (SELECT ROWNUM, MEMBER.* FROM MEMBER) WHERE ROWNUM BETWEEN 6 AND 10;
-- 아무것도 조회되지 않는다
-- WHERE절의 ROWNUM는 SUBQUERY의 ROWNUM을 사용하지 않고 결과집합의 ROWNUM을 사용하기 때문 / ROWNUM Column이 2개다

SELECT * FROM (SELECT ROWNUM NUM, MEMBER.* FROM MEMBER) WHERE NUM BETWEEN 6 AND 10;
-- 따라서 별칭을 통해 SUBQUERY의 ROWNUM을 WHERE절의 조건으로 사용한다

SELECT DISTINCT PWD FROM MEMBER;
-- DISTINCT 중복제거

-- 함수 / 유투브 

-- 연산 절
-- SELECT문의 구절
-- SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY 순서로 작성하는 것이 바람직하다

-- 정렬
SELECT * FROM MEMBER ORDER BY PWD, EMAIL DESC;
-- ASC(ascending) 오름차순은 생략 가능하다
-- DESC(deascending) 내림차순
-- PWD를 기준으로 오름차순 후 EMAIL을 기준으로 내림차순

SELECT * FROM MEMBER WHERE NAME LIKE '강%' ORDER BY ID;
SELECT * FROM MEMBER WHERE REGEXP_LIKE(NAME, '^강') ORDER BY ID;
-- MEMBER테이블에서 '강'씨 성을 가진 회원을 조회 단 나이를 오름차순으로 정렬

-- 집계
-- 집계 함수 SUM, MIN, MAX, COUNT, AVG
SELECT COUNT(ID) COUNT FROM MEMBER;
-- null값을 제외한 데이터 갯수 / 총 갯수를 구하려면 null값이 없는 Column을 조회해야 한다

SELECT AGE, COUNT(ID) COUNT FROM MEMBER GROUP BY AGE ORDER BY AGE;
-- 나이별로 그룹지어서 조회

SELECT NAME, AGE, COUNT(ID) COUNT FROM MEMBER GROUP BY AGE ORDER BY AGE;
-- 에러 - GROUP BY 표현식이 아닙니다 / 같은 나이의 NAME의 값을 합칠 수 없다

SELECT TRUNC(AGE, -1), COUNT(ID) FROM MEMBER GROUP BY TRUNC(AGE, -1) ORDER BY TRUNC(AGE, -1);
-- 연령대별로 그룹지어서 조회

SELECT AVG(AGE) FROM MEMBER WHERE MOD(ID, 2) = 1;
-- ID가 홀수인 평균나이 계산

SELECT 
    (SELECT NAME FROM MEMBER WHERE ID = WRITER_ID) WRITER_NAME,
--  부모 자식 관계이므로 SUBQUERY가 아닌 JOIN으로 하는 게 적절하다
--  MEMBER 테이블에서 MEMBER 테이블의 ID와 NOTICE 테이블의 WRITER_ID가 같은 ROW의 NAME 조회
    COUNT(ID) COUNT
FROM NOTICE
GROUP BY WRITER_ID
HAVING COUNT(ID) >=2
-- WHERE는 집계(GROUP BY) 전 조건 / HAVING은 집계(GROUP BY) 후 조건
ORDER BY COUNT;
-- 실행순서는 FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY 순서로 실행된다
-- 따라서 SELECT가 실행되기 전인 HAVING에선 COUNT 별칭을 사용할 수 없다

-- 2/6
-- 서브 쿼리를 사용하는 경우
-- 1. 구절의 순서를 바꿔야 하는 경우

SElECT * FROM MEMBER ORDER BY REG_DATE DESC
WHERE ROWNUM BETWEEN 1 AND 10;
-- 최신 등록순으로 정렬한 결과에서 상위 열명을 원하는 경우
-- 오류 - 명령어가 올바르게 종료되지 않았습니다 / 쿼리문 순서가 틀리다

SELECT * FROM (SELECT * FROM MEMBER ORDER BY REG_DATE DESC)
WHERE ROWNUM BETWEEN 1 AND 10;
-- 정상적으로 출력된다

SELECT * FROM (SELECT ROWNUM NUM, M.* FROM MEMBER M ORDER BY REG_DATE DESC)
WHERE NUM BETWEEN 11 AND 20;
-- 최신 등록순으로 정렬한 결과에서 11 ~ 20번째를 원하는 경우
-- M - MEMBER 테이블 별칭
-- ROWNUM가 먼저 만들어지고 정렬을 나중에 하기 때문에 원하는 결과가 나오지 않는다
-- ROWNUM은 순서상 WHERE 다음에 만들어진다

SELECT * FROM (
    SELECT ROWNUM NUM, M.* FROM (
        SELECT * FROM MEMBER ORDER BY REG_DATE 
    )M
) WHERE NUM BETWEEN 11 AND 20;
-- 정상적으로 출력된다
-- M - 결과집합의 별칭
-- MEMBER.*을 사용할 수 없다 / FROM 뒤에 MEMBER 테이블이 아닌 결과집합이기 때문(▲) / M.*사용

-- 2. 앞서서 결과값을 구하고 연산할 경우
SELECT * FROM MEMBER WHERE AGE >= (SELECT AVG(AGE) FROM MEMBER);
-- 평균나이 이상인 회원 목록 조회

SELECT * FROM MEMBER WHERE ID = (
    SELECT WRITER_ID FROM (
        SELECT WRITER_ID, COUNT(ID) FROM NOTICE GROUP BY WRITER_ID ORDER BY COUNT(ID) DESC 
    ) WHERE ROWNUM = 1
);
-- 게시글을 가장 많이 올린 회원 정보 조회

SELECT * FROM MEMBER WHERE AGE > ANY(SELECT AVG(AGE) FROM MEMBER GROUP BY GENDER);
-- 성별 평균나이를 상회하는 나이를 가진 회원 정보 조회
-- 격자형 데이터는 비교할 수 없다 / 목록을 단일화 해야한다 / ALL, ANY
-- AGE > ALL(20, 30, 40) - 여러개의 값이 있을 때 (20, 30, 40)모든 값 보다 큰 AGE
-- AGE > ANY(20, 30, 40) - 여러개의 값이 있을 때 (20, 30, 40)중 어떤 한 값보다 큰 AGE

--------------------------------------------------------------------------------

-- 조인(join)
-- INNER JOIN, OUTER JOIN, SELF JOIN, CROSS JOIN(Cartesian Product)
-- JOIN은 주인공(참조 키를 갖고 있는 자식 테이블)이 있고 주인공의 Column이 늘어난다
-- 장점 / 성능 향상 / 데이터 결함을 없앤다
-- 메모리에서 1개만 가져오는 I/O와 3개를 가져오는 I/O가 있다면 1개가 압도적으로 빠르다

SELECT 
    (SELECT NAME FROM MEMBER WHERE ID = WRITER_ID) WRITER_NAME,
    COUNT(ID) COUNT
FROM NOTICE
GROUP BY WRITER_ID
HAVING COUNT(ID) >=2
ORDER BY COUNT;

SELECT M.ID MEMBER_ID, M.NAME MEMBER_NAME, N.ID, N.TITLE
-- 어느 테이블의 ID인지 구분 / 주인공은 원래 이름을 사용한다
FROM MEMBER M
    JOIN NOTICE N
    ON M.ID = N.WRITER_ID;
-- INNER를 써주지 않아도 기본이 INNER JOIN / 참조키를 기준으로 일치하는 행만 조인
-- NOTICE가 주인공 이므로 NOTICE의 레코드 수 만큼 조회된다
-- 레코드 수 만큼 안 나온다면 부모가 없는 자식 레코드 OUTER가 있다는 의미
-- MEMBER테이블이 만들어지고 MEMBER가 글을 쓰면 NOTICE테이블이 만들어지므로 NOTICE가 자식이다

SELECT M.ID MEMBER_ID, M.NAME MEMBER_NAME, N.ID, N.TITLE
FROM MEMBER M
    RIGHT JOIN NOTICE N
    ON M.ID = N.WRITER_ID;
-- LEFT/RIGHT/FULL OUTER JOIN / OUTER 생략가능 / 참조키를 기준으로 일치하지 않는 행도 조인
-- LEFT JOIN / INNER JOIN을 한 뒤 왼쪽 테이블의 OUTER도 결과 record에 포함
-- RIGHT JOIN / INNER JOIN을 한 뒤 오른쪽 테이블의 OUTER도 결과 record에 포함
-- FULL JOIN / INNER JOIN을 한 뒤 양쪽 테이블의 OUTER도 결과 record에 포함
-- OUTER JOIN은 선택한 주인공 테이블을 다 보여주는 JOIN이다 / 빈 곳은 null로 채움

-- 2/7
SELECT M.ID, M.NAME, COUNT(N.ID)
FROM MEMBER M
    LEFT JOIN NOTICE N
    ON M.ID = N.WRITER_ID
GROUP BY M.ID, M.NAME;
-- 회원별 게시글 수 조회
-- LEFT OUTER JOIN해줘야 모든 회원이 나온다

SELECT N.ID, N.TITLE, M.NAME, COUNT(C.ID)
FROM NOTICE N
    LEFT JOIN MEMBER M
    ON M.ID = N.WRITER_ID
    LEFT JOIN "COMMENT" C
    ON N.ID = C.NOTICE_ID
GROUP BY N.ID, N.TITLE, M.NAME;
-- 부모(MEMBER)걸 가져올 때는 그냥 가져와도 된다 / 자식(주인공, NOTICE)의 참조키 RECORD만큼 부모가 복제되기 때문.
-- 자식(COMMENT)걸 가져올 때 자식의 참조키 RECORD만큼 부모(주인공, NOTICE)가 복제되기 때문에 집계함수로 묶어줘야 한다.
-- 집계하지 않은 나머지 Column은 GROUP BY로 묶어줘야 한다 / GROUP BY에선 *을 사용할 수 없다.
-- 예약어 COMMENT는 ""로 감싸줘야 한다.

-- SELF JOIN
-- 데이터가 서로 포함 관계를 가지는 경우 : 담당, 구성, 연락
-- 학생 테이블에서 조장인 학생과 조원인 학생이 있다
-- 조원인 학생이 자신의 조장을 가르키는 Column을 가지고 있을 경우 SELF JOIN을 할 수 있다

SELECT M.ID, M.NAME, M.BOSS_ID, B.NAME
FROM MEMBER M
    LEFT JOIN MEMBER B
    ON M.BOSS_ID = B.ID;
-- INNER 조인이라면 BOSS_ID가 있는 MEMBER만 결과에 나온다
-- M 자식테이블, B 부모테이블 / BOSS_ID가 참조키
-- M.BOSS_ID만큼 B.NAME이 복제된다 / B.BOSS_ID는 보스의 BOSS_ID가 나온다
    
-- CROSS JOIN
-- ON이 없다 / 테이블간 관계가 없다 / 더미 데이터
SELECT * FROM MEMBER CROSS JOIN "COMMENT";

-- UNION 조인
-- Column이 늘어나지 않고 RECORD가 늘어난다 / Column수는 맞춰줘야 한다
SELECT 'NOTICE' TYPE, ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%'
UNION
SELECT 'COMMENT' TYPE, ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%';
-- Column명이 CONTENT는 무시되고 TITLE로 나온다
-- 결과
--  TYPE   | ID | TITLE
-- NOTICE  |  4 | 재재
-- COMMENT |  4 | 재재
-- COMMENT |  5 | 재수

SELECT ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%'
UNION
SELECT ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%';
-- 위 결과에서 TYPE을 뺏다 / 레코드의 값이 전부 같다면 합쳐진다
-- 결과
-- ID | TITLE
--  4 | 재재
--  5 | 재수

SELECT ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%'
UNION ALL
SELECT ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%';
-- 합치지 않고 모든 RECORD를 보고 싶다면 UNION ALL을 한다
-- 결과
-- ID | TITLE
--  4 | 재재
--  4 | 재재
--  5 | 재수

SELECT ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%'
MINUS
SELECT ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%';
-- MINUS / 첫 번째 결과 집합에서 두 번째 결과 집합을 뺀다
-- 모든 레코드의 값이 겹치지 않은 첫 번째 결과 집합만 조회된다
-- 결과는 아무것도 나오지 않는다

SELECT ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%'
INTERSECT
SELECT ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%';
-- INTERSECT / 첫 번째 결과 집합과 두 번째 결과 집합의 교집합
-- 모든 레코드의 값이 공통된 RECORD만 조회된다
-- 결과
-- ID | TITLE
--  4 | 재재

SELECT ID, CONTENT FROM "COMMENT" WHERE CONTENT LIKE '%재%'
MINUS
SELECT ID, TITLE FROM NOTICE WHERE TITLE LIKE '%재%';

-- VIEW
-- 물리적인 데이터구조(TABLE)와 개념적인 데이터구조(View)의 차이
-- 컬럼의 결합만 있어야 한다
-- WHERE, ORDER BY가 있으면 안 된다
-- 사용자에게 여러개의 테이블을 조합해서 원하는 결과를 보여준다
-- 하나의 테이블로도 VIEW를 만드는 경우는 있다 / 가리고 싶은 Column이 있는 경우


SELECT * FROM NOTICE_VIEW;
-- 뒤에 _VIEW를 붙여 Table과 구분해준다
-- 쿼리 문장에 이름만 붙여 실행해준거다

-- System Data / Data Dictionary
-- 사용자 정보를 저장하기 위해서 

-- Dictionary View
-- 아는사람도 없고 / 사용하는 사람도 없다
SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLUMNS;