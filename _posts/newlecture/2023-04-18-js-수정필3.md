---
title: js
tags: 
---

```js
this.x = 30;

setTimeout(() => {
    console.log(this.x);
}, 1500);

setTimeout(function() {
    console.log(this.x);
}, 1500);

class Test{
    constructor(){
        this.x = 10;

        setTimeout(() => {
            console.log(this.x)
        }, 1500);

        setTimeout(function() {
            console.log(this.x);
        }, 1500);
    }
}

new Test();
```

출력결과는 순서대로 30 30 10 30
람다는 자기만의 this가 없어서 outer의 this를 쓴다

```js
this.x = 30;

setTimeout(() => {
    console.log(arguments.length);
}, 1500);

setTimeout(function() {
    console.log(arguments.length);
}, 1500);
```

애로우 함수는 에러 두 번째 function는 0이 나온다
에로우는 아규먼트가 아닌 파라미터로 받는다
애로우는 간단한 수식을 반환할 때 사용


```js
class Exam {
    constructor(kor = 0, eng = 0, math = 0) {
        this.kor = kor;
        this.eng = eng;
        this.math = math;
    }


    total() {
        return this.kor + this.eng + this.math;
    }
    avg() {
        return this.total() / 3;
    }
}

class NewExam extends Exam {
    constructor(kor = 0, eng = 0, math = 0, com = 0) {
        super(kor, eng, math);
        this.com = com;
    }

    total() {
        return super.total() + this.com;
    }

    #test(){
        console.log("test")
    }

    getKor(){
        return this.kor;
    }

    setKor(kor){
        this.kor = kor;
    }
}
```

NewExam의 constructor에서 super를 꼭 써야한다
total() 재정의 필요
test() #을 붙여서 은닉성추가. 이젠 함수 test를 밖에서 사용할 수 없다

```js
var obj = {
    "to-string"(){
        console.log("hello");
    },

    hi(){
        console.log("hi");
    }
}

obj["to-string"]();
obj.hi();
```

[]안엔 변수명, 연산자가 올 수 있다.

```js
var q = {
    kor
}
```

변수명과 키가 같은 이름일 경우에는 키를 별도로 설정할 필요가 없다.

## Template Strings

```js
let tem = `\\<span>yay~</span>\\`

console.log(tem); // \<span>yay~</span>\
```

익스케이프 문자

```js
let tem = `\\<span>
            yay~
            </span>\\`

console.log(tem);
// \<span>
// yay~
// </span>\
```

엔터가 먹는다

```js
let tem = String.raw`\\<span>
            yay~\n
            </span>\\`

console.log(tem);
```
기본적으로 \n 먹어 줄 바꿍이 되지만 String.raw를 하면 줄바꿈 되지 않고 \n이 출력된다

## Spread Operator

```js
function print(x, y, z){
    console.log(`x:${x}, y:${y}, z:${z}`);
}

let ar = [2,3,4];

print(ar[0], ar[1], ar[2]);
print(...ar);
```

print를 두 번 호출했지만 결과는 같다

## Iterators

```js
let lo = new Set();

lo.add(1);
lo.add(2);
lo.add(3);
lo.add(4);
lo.add(5);
lo.add(6);

console.log(lo); // Set(6) {1, 2, 3, 4, 5, 6}
console.log(lo.entries().next()); // {value: Array(2), done: false}
console.log(lo.keys().next()); // {value: 1, done: false}
console.log(lo.values().next()); // {value: 1, done: false}
```

js에선 Collection이 없다가 생겼다???
유일한 콜렉션 : Array
일반적인 언어에서 지원하는 콜렉션 : set, Array, map
콜렉션이 가져야 할 기능 : 값들을 열거할 수 있느냐

객체도 entry를 통해 나열할 순 있다???

entries 키와 값을 배열로 반환하는 이터레이터
keys 키만 반환하는 이터레이터
values 값만 반환하는 이터레이터

```js
let lo = new Set();

lo.add(1);
lo.add(2);
lo.add(3);
lo.add(4);
lo.add(5);
lo.add(6);

let it = lo.values();

for (let n of it)
    console.log(n);

let kvit = lo.entries();
for (let [k, v] of kvit)
    console.log(`key:${k}, value:${v}`);
```

이터레이터 활용

첫 번째 for 결과
1
2
3
4
5
6

두 번째 for 결과
key:1, value:1
key:2, value:2
key:3, value:3
key:4, value:4
key:5, value:5
summary.js:88 key:6, value:6

```js
let ar = [3,5,7,9];
let arkvit = ar.entries();

for (let [k, v] of arkvit)
    console.log(`key:${k}, value:${v}`);
```

배열에서 이터레이터를 얻어 for문 결과
key:0, value:3
key:1, value:5
key:2, value:7
key:3, value:9

## Foreach

```js
let map = new Map();
map.set("id", 1);
map.set("title", "제목");
map.set("content", "내용");

map.forEach((v, k, m) => {
    console.log(`key:${k}, value:${v}, cols:${m}`)
})
```

## Symbols

```js
function iterator() {
    console.log("휴");
}

function print(it){
    for(let n of it)
    console.log(n);
}

print(iterator());
```

내가 iterator를 만들었지만 이름만 같지 하는 역할은 완전히 다르다.
에러 - it is not iterable at print

```js
function iterator() {
    return [2, 3, 4];
}

function print(it){
    for(let n of it)
    console.log(n);
}

print(iterator());
```

출력결과
2
3
4

```js
let s = Symbol();

let a = {
    kor:10,
    [s](){
        return this.kor
    }
}

console.log(a[s]());
```

출력결과
10

심볼은 약속된 이름을 만드는 것
심볼은 절대 같은 값을 만들어 내지 않는다.
인터페이스를 정의할 방법이 없다보니 심볼이 생겼다.
이렇기 때문에 함수명에 []를 써서 변수명을 넣을 수 있는 것이다.

```js
let exam = {
    kor: 10,
    eng: 20,
    math: 30,
    values() {
        return {
            next() {
                return {
                    done: false,
                    value: this.kor
                }
            }
        }
    }
}

for(let n of exam.values())
    console.log(n);
```

에러 - exam.values is not a function or its return value is not iterable
이터레이터와 완벽히 구조가 같지만 에러가 난다.
이터레이터를 반환한다는 보장이 있어야 한다. [Symbol.iterator]()로 정의해야 한다?
