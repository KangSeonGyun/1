---
title: js2 dom
tags: 
---

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="module" src="dom.js" defer></script>
</head>
<body>
    <section class="s3" tabindex="0">
        <h1>이미지목록</h1>
        <style>
            .s3 ul{
                padding: 0;
                list-style-type: none;
                display: flex;
            }

            .s3 span{
                display: inline-flex;                
                width:100px;
                height: 100px;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                background-color: blue;

                /* transition: .5s; */                
            }            

            .s3 li.selected .box,
            .s3 li.selected span
            {
                box-sizing: border-box;
                background-color: red;
            }

        </style>
        <div>
            <button class="btn-del">삭제</button>
        </div>
        <ul>
            
            <li><input type="checkbox"><span>1</span></li>
            
            <li>
                <input type="checkbox">
                <div>
                    <span>2</span>
                </div>
            </li>
            
            <li><input type="checkbox"><span>3</span></li>
            
            <li><input type="checkbox"><span>4</span></li>
        </ul>
    </section>
    <hr>
    <section class="s2">
        <h1>이미지목록</h1>
        <style>

            @keyframes current {
                from {
                    transform: scale(1,1);
                }

                /* 30%{
                    transform: rotate(360deg);
                }

                60%{
                    transform: rotate(-360deg);
                } */

                to {
                    transform: scale(1.2,1.2);
                }
            }

            @keyframes selectedani {
                from {
                    transform: rotate(0deg);
                }

                to {
                    transform: rotate(360deg);
                }
            }

            .s2 ul{
                padding: 0;
                list-style-type: none;
                display: flex;
            }

            .s2 span{
                display: inline-flex;                
                width:100px;
                height: 100px;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                background-color: blue;

                /* transition: .5s; */                
            }            

            .s2 li.current .box,
            .s2 li.current span
            {
                box-sizing: border-box;
                background-color: red;
                border:3px solid yellow;
                /* width: 120px;
                height: 120px; */
                /* transform: scale(1.2,1.2); */
                animation-name: current;
                animation-duration: .5s;
                animation-iteration-count: infinite;
                animation-direction: alternate;
            }

            .s2 li.selected .box,
            .s2 li.selected span
            {                
                animation-name: selectedani;
                animation-duration: 2s;
                animation-direction: alternate;
            }
        </style>
        <ul>
            <li><span>1</span></li>
            <li>
                <div>
                    <span>2</span>
                </div>
            </li>
            <li><span>3</span></li>
            <li><span>4</span></li>
        </ul>
    </section>
    <hr>
    <section id="s1" class="tool section1">
        <h1 class="aaa">문서</h1>
        <div>
            <button class="btn-up">위</button>
            <button class="btn-down">아래</button>
        </div>
        <ul>
            <li class="current">a-current</li>
            <li>b</li>
            <li>c</li>
            <li>d</li>
            <li>e</li>
        </ul>
    </section>
    hello
</body>
</html>
```

```js
window.addEventListener("load", function () {

    // .s3 목록을 키보드로 정리
    {
        let s3 = document.querySelector(".s3");
        let ul = s3.querySelector("ul");
        let lis = ul.querySelectorAll("li");
        let current = null;

        let delButton = s3.querySelector(".btn-del");
        s3.focus();

        ul.onclick = function (e) {
            if (e.target.tagName !== "SPAN")
                return;

            let selected = e.target.parentElement;
            console.log(selected);
            while (selected.tagName !== 'LI')
                selected = selected.parentElement;


            selected.classList.add("selected");

        }


        delButton.onclick = function () {
            // 버블링
            // 계산기를 만들 때 1~9 입력은 같은 코드일 것이다
            // 부모에서 한 번만 처리하기 위해 버블링이 생겼다

            let selectedButtons = [...ul.querySelectorAll("input:checked")]
                .map(a => a.parentElement);
            // ...은 Spread syntax 낱개로 만든다. 그후 [] 배열로 감쌌다.

            // .foreach는 of와 같이 소비만하고 반환이 없다
            // .map은 배열에서 하니씩 꺼내쓰는 것은 같지만 반환 배열이 만들어진다.

            for (let li of selectedButtons)
                li.remove();
        }

        s3.onkeydown = function(e){
            console.log(`code : ${e.code}, key : ${e.key}, keycode : ${e.keycode}`);
            // onkeydown때 클릭이 발생한 것처럼 하여 delButton.onclick을 실행했다. 이벤트를 트리거 했다. trigging
            const event = new Event("click");
            delButton.dispatchEvent(event);
        }
    }

    // 4. 이벤트 객체
    {
        let s2 = document.querySelector(".s2");
        let ul = s2.querySelector("ul");
        let lis = ul.querySelectorAll("li");
        let current = null;

        for (let li of lis)
            li.onclick = function (e) {
                // if (current) {
                //     let pre = current.previousElementSibling

                //     e.target.parentElement.replaceWith(current);

                //     if (pre)
                //         pre.after(e.target.parentElement);
                //     else
                //         ul.prepend(e.target.parentElement);

                //     console.log(pre);

                //     return;
                // }

                if (current) {
                    // 모든 li를 for문으로 돌면서 current 클래스가 있는지 확인하는 것 보단 current로 바로 하는 게 바람직하다.


                    //current<->selected
                    // 1. 현재 2번째 선택된 엘리먼트 얻기
                    let selected = e.target.parentElement;
                    while (selected.tagName !== 'LI')
                        selected = selected.parentElement;

                    selected.classList.add("selected");
                    selected.onanimationend = function () {

                        selected.classList.remove("selected");

                        let selectedBefore = selected.previousElementSibling;
                        current.replaceWith(selected);
                        if (selectedBefore)
                            selectedBefore.after(current);
                        else
                            ul.prepend(current);

                        current.classList.remove("current");
                        current = null;

                    }

                    // selected.onadimationend();

                    return;
                }


                current = e.target.parentElement;
                while (current.tagName !== "LI")
                    current = current.parentElement;

                current.classList.toggle("current");
                console.log(current);
            }
    }

})
```

## 드래그앤 드랍

모양 드래그 드랍과 데이터 드래그 드랍이 있다.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="module" src="dom.js" defer></script>
</head>
<body>
    <section class="s4">
        <style>
            .s4 .drop-zone{
                box-sizing: border-box;
                width: 500px;
                height: 400px;
                border: 1px solid gray;
                background-color: beige;
            }
            .s4 .box-zone{
                display: flex;
            }
            .s4 .box{
                box-sizing: border-box;
                width: 100px;
                height: 100px;
                background-color: green;
            }
        </style>
        <h1>Drag and Drop API</h1>
        <div class="drop-zone">
            drop-zone
        </div>
        <div class="box-zone">
            box-zone
            <div class="box">1</div>
            <div class="box">2</div>
            <div class="box">3</div>
            <div class="box">4</div>
        </div>
    </section>
    
</body>
</html>
```

Drag and Drop API

drop 할 때 내가 드래그한 데이터를 읽으려는 행동이 있다. ondragover과 ondrop 기본 행동을 막았다.
이렇게 하면 console에 drop이 찍힌 것을 볼 수 있다.

```js
    {
        let s4 = this.document.querySelector(".s4");
        let dropZone = s4.querySelector(".drop-zone");

        dropZone.ondragenter = function(e){
            console.log("enter");
        };

        dropZone.ondragover = function(e){
            e.preventDefault();
            console.log("over");
        };

        dropZone.ondragleave = function(e){
            console.log("leave");
        };

        dropZone.ondrop = function(e){
            e.preventDefault();
            console.log("drop");
        };
    }
```

draggable="true"로 하면 드래그를 할 수 있게 된다

```html
<div draggable="true" class="box">1</div>
```

dragover 때 데이터 타입을 알 수 있다
File은 e.dataTransfer.types 배열 0번째에 Files가 있다.
이걸 이용해 사용자에게 파일을 올리게 유도할 수 있다

```js
dropZone.ondragover = function (e) {
            e.preventDefault();

            if (e.dataTransfer.types[0] == "Files") {
                dropZone.classList.add("valid");
                dropZone.classList.remove("invalid");
            }
            else {
                dropZone.classList.add("invalid");
                dropZone.classList.remove("valid");
            }

        };
```

두 개 이상의 파일을 올렷을 때 콘솔 출력

```js
        dropZone.ondrop = function (e) {
            e.preventDefault();
            console.log(e.dataTransfer.types);
            console.log("drop");

            if (e.dataTransfer.files.length > 1)
                console.log("두 개 이상의 파일은 업로드 할 수 없습니다.");
        };
```

## Progress Event, 파일 전송

html에서 formData로 파일 전송, 드래그 드랍으로 파일

```js
        dropZone.ondrop = function (e) {
            e.preventDefault();
            console.log(e.dataTransfer.types);
            console.log("drop");

            if (e.dataTransfer.files.length > 1)
                console.log("두 개 이상의 파일은 업로드 할 수 없습니다.");

            let file = e.dataTransfer.files[0];
            let formData = new FormData();
            formData.append("file", file);
            formData.append("test", "hehe");

            let request = new XMLHttpRequest();

            request.onload = function(){
                console.log("done");
            }

            request.upload.onprogress = function(){
                console.log("progress");
            }
            // fetch와 다르게 처리하는 과정을 볼 수 있다.

            request.open("POST", "http://localhost:8080/upload");
            // request.setRequestHeader("Content-Type", "multipart/form-data");
            request.send(formData);
        };
```

서버쪽 컨트롤러

```java
@CrossOrigin(origins = "http://127.0.0.1:5500")
@RestController
@RequestMapping("/")
public class HomeController {

    @GetMapping
    public String index() {
        return "hello index";
    }

    @PostMapping("upload")
    public ResponseEntity<String> upload(MultipartFile file, HttpServletRequest request)
            throws IllegalStateException, IOException {
        // 업로드 할 파일이 없다면 continue
        // 만약 break를 한다면 첫번째 파일이 없고 두번째만 있을경우 문제가 생긴다
        if (file.isEmpty())
            return new ResponseEntity<String>("파일을 전송하지 않았습니다.", HttpStatus.BAD_REQUEST);

        String urlPath = "/upload";
        String realPath = request.getServletContext().getRealPath(urlPath);
        // 서비스할때 프로그램이 어느 위치에 있을지 모르기때문에.. 서버의 홈디렉토리 경로를 지정해준다.
        // 물리적인경로 //servlet API에 있는 기능을 사용한다.(realPath)
        // realPath = this.getClass().getResource("/").getPath(); //자바의 자체 기능임
        // 4대 저장소 page context, request, session, application

        System.out.println(realPath);

        File filePath = new File(realPath);

        if (!filePath.exists())
            filePath.mkdirs();

        String fileName = file.getOriginalFilename();
        File saveFile = new File(filePath + File.separator + fileName);
        file.transferTo(saveFile);

        return new ResponseEntity<String>(fileName, HttpStatus.OK);
        // 응답할때의 정보를 담을 수 있는 그릇 -> ResponseEntity
        // 응답그릇. String 뿐만 아니라 다양한 데이터를 보낼 수 있다.
    }

}
```