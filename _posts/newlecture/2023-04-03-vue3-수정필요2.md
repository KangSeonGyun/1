---
title: Vuejs 3
tags: vue javascript
---

## SPA(Single Page Application)

전체 애플리케이션을 단일 페이지에서 구현하려고 한다.   
사용자는 처음에 한 번 페이지를 로드한 후에 페이지 전체를 다시 로드하지 않고 동적으로 콘텐츠를 업데이트하기 때문에 페이지 전환이 부드러운 경험을 할 수 있다.   
하나의 페이지로 구성하고, 페이지 내의 여러 구성 요소를 동적으로 조작하며 필요한 데이터만 서버로부터 비동기적으로 가져온다.   
이제 SSR 방식처럼 page를 새로만드는 것이 아닌 데이터만 바꿔끼게 되므로 사용자는 페이지가 새로고침 됐다고 느낄 수 없다.   

## .vue를 이용해 page 분리

page를 분리할 때의 장점은 이전 tiles를 설명할 때 했었으니 생략.   

### index.html

```html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="/css/reset.css" type="text/css" rel="stylesheet">
    <link href="/css/style.css" type="text/css" rel="stylesheet">
    <link href="/css/layout.css" type="text/css" rel="stylesheet">
    <link href="/css/header.css" type="text/css" rel="stylesheet">
    <link href="/css/footer.css" type="text/css" rel="stylesheet">

    <link href="/css/user/find-id.css" type="text/css" rel="stylesheet">
    <link href="/css/buttons.css" type="text/css" rel="stylesheet">
    <link href="/css/icon.css" type="text/css" rel="stylesheet">
    <link href="/css/deco.css" type="text/css" rel="stylesheet">
    <link href="/css/utils.css" type="text/css" rel="stylesheet">
</head>

<body>
    <div id="app"></div>
    <script type="module" src="src/main.js"></script>
    <!-- 이 스크립트는 마지막에 실행 되야 한다. -->
    <!-- 스크립트가 원래 index.html에 있는 텍스트를 날린다. 스크립트 뒤에 내용이 있으면 그 내용이 출력된다 -->
</body>


</html>

```

### main.js

```js

import App from './App.vue'
import { createApp } from 'vue'

createApp(App)
.mount("#app")

```

### App.vue

```vue

<script>
import Header from "./components/Header.vue";
import Footer from "./components/Footer.vue"

export default {
    components:{
        Header,
        Footer
    },
    data() {
        return {
            test: "hello"
        };
    }
}
</script>

<template>

    <Header />
    <!-- export한 것을 app.vue가 받고 app.vue가 뿌린다 -->
    
    <!-- ---------------------------------------------------------------------- -->
    
    <!-- 여기엔 메인 내용이 있을 것이다. -->
    
    <!-- ---------------------------------------------------------------------- -->
    
    <Footer />
</template>

```

### Header.vue

```vue

<template>
    <header class="header fixed-header">
        <div>
            <h1 class="header-title"><a href="/index"><img class="logo" src="/image/logo-w.png" alt="알랜드"></a></h1>

            <ul class="main-menu d-none d-inline-flex-sm">
                <li><a class="" href="/menu/list">카페메뉴</a></li>
                <li><a class="" href="/notice/list">공지사항</a></li>
                <li><a class="" href="/user/login">로그인</a></li>
            </ul>
            <div class="d-none-sm"><a class="icon icon-menu icon-white" href="?m=on">메뉴버튼</a></div>
        </div>
    </header>
</template>

```

### Footer.vue

```vue

<template>
    <footer class="footer">
        <h2>알랜드(Rland)</h2>
        <div>
            copyright @ rland.co.kr 2022-2022 All Right Reservved. Contact admin@rland.co.kr for more information
        </div>
    </footer>
</template>

```

## Vuejs에서 페이지 간 이동을 위한 라이브러리 Vue Router 사용

네트워크에서 routing과 웹에서 routing은 좀 다르다.   
네트워크에서의 라우팅은 데이터 패킷이 네트워크를 통해 목적지까지 전달되는 경로를 결정하는 과정이다.   
웹에서의 라우팅은 사용자의 요청 URL을 기반으로 웹 애플리케이션 내에서 적절한 동작이나 페이지를 매핑하는 것을 의미한다.   

```vue
<router-view></router-view>
```
Vue Router는 라우터 설정에 따라서 현재 URL에 맞는 컴포넌트를 식별하고, 해당 컴포넌트를 router-view에 렌더링합니다.   

```vue
<router-link to="/index">Home</router-link>
```

router-link는 사용자가 클릭할 수 있는 링크를 제공한다.   
Vue Router와 연결되어 현재 URL을 변경하고 페이지를 다시 렌더링한다.   
컴파일 시, <a> 태그로 변환된다.   
v-bind와 함께 사용하면 동적으로 경로를 만들 수 있다.

### 랜더링이란?

웹 개발에서의 랜더링은 서버로부터 전달받은 HTML, CSS, JavaScript 등의 웹 페이지와 관련된 자원들을 해석하여 브라우저에서 실제로 표시되는 화면을 생성하는 과정이다.

랜더링은 두 단계로 나눠진다.

첫째, 브라우저가 HTML 문서를 파싱하여 DOM(Document Object Model) 트리를 구성한다.   
DOM 트리는 HTML 요소들과 요소 간의 계층 구조를 나타내며, 웹 페이지의 구조와 콘텐츠를 표현한다.

둘째, CSS 스타일 정보를 적용하여 각 요소의 위치, 크기, 색상 등을 계산하고, 레이아웃을 구성한다.   
이후, 렌더링 엔진은 최종적으로 화면에 그래픽을 그려 웹 페이지를 시각적으로 표시합니다.

### Vue Router 예제

해당 예제에선 일반 index page와 admin index page의 layout이 다르다고 가정했다.   
여기서 router-view는 2개다.   
App.vue에서 Layout과 AdminLayout 갈 때 1개   
Layout에서 Index와 About을 갈 때 1개

```vue

import App from './App.vue';
import { createApp } from 'vue';
import { createRouter, createWebHashHistory } from 'vue-router';

import Layout from './components/Layout.vue';
import Index from './components/Index.vue';
import List from './components/menu/List.vue';
import Detail from './components/menu/Detail.vue';
import About from './components/About.vue';

import AdminLayout from './components/admin/Layout.vue';
import AdminMenuList from './components/admin/menu/List.vue';

const routes = [
    {
        path: '/index', component: Index
    },
    {
        path: '/', component: Layout, children: [
            { path: 'menu/list', component: List },
            { path: 'menu/:id', component: Detail }
        ]
    },
    {
        path: '/admin', component: AdminLayout, children: [
            { path: 'menu/list', component: AdminMenuList }
        ]
    }
]


const router = createRouter({
    // 4. Provide the history implementation to use. We are using the hash history for simplicity here.
    history: createWebHashHistory(),
    routes, // short for `routes: routes`
})

createApp(App)
    .use(router)
    .mount("#app")

```

/admin이 루트(레이아웃)다. 따라서 /admin이 사용자가 접근하는 경로로 사용된다면 잘못된 것이다.   
만약 /admin 에서 링크 menu/list를 클릭하면 /admin/menu/list 로 가지 않고 /menu/list 로 간다.

Layout의 children에 들어온 .vue들은 Layout과 url을 이어받는다.

AdminMenuList의 path를 '/menu/list'와 같이 /로 시작하면 사용자가 접근하는 url은 admin/menu/list이 아닌 /menu/list가 된다.   
상속 받아야 할 url인 /admin을 무시해버린 것. 하지만 컴포넌트(AdminLayout)는 상속받는다.   

## 스타일 스코프

```css
<style scoped>
.header {
    position: fixed;
}
</style>
```

scoped를 안 쓰면 모든 vue 페이지 에서 스타일이 적용된다.   
하지만 css를 따로두는 이유는 Index.vue를 볼 때 다른 페이지의 css가 필요 없기 때문이다.

위 예제에서 Layout과 List는 포함관계 지만 Index와 List는 포함관계가 아님에도 style이 공유된다.   
components안에 있는 모든 style을 공유하기 때문이며 이를 방지하려면 scoped를 설정해줘야 한다.   
scoped를 사용하면 이름 충돌을 피할 수 있다. 개발자 도구로 열어보면 style 태그에 식별자가 붙는다.

## 상품에 맞는 detail 페이지 표시하기

### 쿼리스트링 사용

링크 거는 방법   
'detail/메뉴 id'를 이용해 해당 페이지로 이동한다.

```vue
<router-link :to="'detail?id=' + m.id"></router-link>
```

detail 페이지로 이동 후 쿼리스트링에서 값 져오는 방법   
${this.$route.query.id}을 이용한다.   
즉, 쿼리스트링에서 id를 가져오고 그 id를 이용해 다시 데이터를 요청해 view에서 사용하려 한다.

```vue
fetch(`http://localhost:8080/menus/${this.$route.query.id}`)
```

그럼 화면이 뜨기 전 단계에서 데이터 요청 한다면?
원하는 화면이 나오지만 콘솔에 에러가 뜬다.
beforeCreate menu는 undefined - 아직 data()도 만들어지지 않았다.
그 후 단계 created, beforeMount, mounted에선 menu가 null이고 페이지는 안 뜰 것이다

하지만 mounted 단계 전에 데이터를 빨리 받아온다면 menu가 null이라는 에러가 콘솔에 뜬 상태로 원하는 페이지가 보여질 것이다.

페이지가 보이기 전 단계(mounted)에서 데이터를 요청하는 것은 바람직 하지 않고 이후 menu가 null이 아닐 때 화면을 update하는 게 바람직 하다

해결 방법 - v-if를 하여 menu가 null이 아닐 때 update를 하여 화면을 갱신 해야 한다.

v-if는 안 보일땐 처리자체를 안한다

v-show 보이든 안 보이든 처리한다. d-none를 하는듯?

v-bind, css 와 같은 것은 화면에 보여졌을 때 효과를 줄 수 있는 것이다.


### url 경로에서 가져오기

링크 거는 방법
<router-link :to="'./' + m.id"></router-link>

url 경로에서 값 가져오는 방법
${this.$route.params.id}

url경로가 바뀌었으므로 vue router의 path도 다음과 같이 수정해야 한다
path: 'menu/:id'
이것은 menu/ 뒤에 붙은 url을 id라는 이름으로 쓴다는 것.
url 경로에서 값을 가져올 때 ${this.$route.params.id} 마지막 .id쓴 이유가 이것이다.



--

서버에 데이텨 요청과 CORS 방법

```js
<script>
import NewMenuList from './NewMenuList.vue';


export default {
    data() {
        return {
            list: [{}, {}, {}],
            newList: []
        };
    },
    mounted() {
        fetch("http://localhost:8080/menus")
            .then((response) => response.json())
            .then(data => {
                this.list = data.list;
                this.newList = data.newList;
            });
        // 첫 번째 then에서 response.json()을 {}로 감싸고 return을 생략한다면 다음 then은 return 받는게 없다? 확인필요
        // 두 번째 화살표 함수에서 {}를 안쓰면 this.list = list를 return한다는 의미이다. 하지만 {}를 생략해줘도 된다.
        // 사용자가 서버(origin) 문서(single page)를 요청하고 그 후 데이터를 요청한다. 요청하는 origin이 같다.
        // 문서를 요청하는 서버와 데이터를 요청하는 서버가 다를 수 있다. cross origin
        // 현재는 다른 origin을 갖고 있는 사용자에게 데이터를 줄지 말지는 서버가 정한다
        // 서버 허용 방법 spring에서 class, method 등 에 @CrossOrigin(origins = "http://localhost:5173/")
        // spring에서 - global하게 설정하는 방법
        // @Bean
        // public WebMvcConfigurer corsConfigurer() {
        //     return new WebMvcConfigurer() {
        //         @Override
        //         public void addCorsMappings(CorsRegistry registry) {
        //             registry.addMapping("/**").allowedOrigins("http://localhost:5173/");
        //         }
        //     };
        // }
        // /*은 루트 바로 아래만 /**은 루트 아래 아래 아래 ... 포함
        // 참고 링크 https://spring.io/guides/gs/rest-service-cors/#controller-method-cors-configuration
    },
    components: { NewMenuList }
}

</script>
```

## Vue의 build과정

.vue 파일에는 HTML, CSS, JavaScript 코드가 포함되어 있다.   
.vue 파일을 build하게 되면 Vuejs 애플리케이션을 실행할 수 있는 js 파일이 되며 필요한 자원(이미지, CSS, JavaScript 파일 등)을 합쳐 번들링하여 웹 애플리케이션을 실행할 수 있는 형태로 만듭니다.

### 번들링이란?   

웹 애플리케이션에서 필요한 모든 자원(HTML, CSS, JavaScript, 이미지 등)을 하나의 파일로 묶는 과정이다.   
많은 개발자들이 동시에 작업할 경우, 여러 파일이 분산되어 있을 수 있다. 번들링을 통해 이러한 파일들을 하나로 묶을 수 있으므로, 프로젝트의 관리와 유지보수가 용이해진다.   