---
title: Vue
tags: vue javascript
---

나눠서 만들 때 장점

1. 협업가능
2. 재사용, 집중화 가능

Single page Application
index페이지

.vue를 이용해 page 분리하기

.vue 파일은 나중에 vue가 js로 컴파일한다

### index.html

```html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="/css/reset.css" type="text/css" rel="stylesheet">
    <link href="/css/style.css" type="text/css" rel="stylesheet">
    <link href="/css/layout.css" type="text/css" rel="stylesheet">
    <link href="/css/header.css" type="text/css" rel="stylesheet">
    <link href="/css/footer.css" type="text/css" rel="stylesheet">

    <link href="/css/user/find-id.css" type="text/css" rel="stylesheet">
    <link href="/css/buttons.css" type="text/css" rel="stylesheet">
    <link href="/css/icon.css" type="text/css" rel="stylesheet">
    <link href="/css/deco.css" type="text/css" rel="stylesheet">
    <link href="/css/utils.css" type="text/css" rel="stylesheet">
</head>

<body>
    <div id="app"></div>
    <script type="module" src="src/main.js"></script>
    <!-- 이 스크립트는 마지막에 실행 되야 한다. -->
    <!-- 스크립트가 원래 index.html에 있는 텍스트를 날린다. 스크립트 뒤에 내용이 있으면 그 내용이 출력된다 -->
</body>


</html>

```

### main.js

```js

import App from './App.vue'
import { createApp } from 'vue'

createApp(App)
.mount("#app")

```

### App.vue

```vue

<script>
import Header from "./components/Header.vue";
import Footer from "./components/Footer.vue"

export default {
    components:{
        Header,
        Footer
    },
    data() {
        return {
            test: "hello"
        };
    }
}
</script>

<template>

    <Header />
    <!-- export한 것을 app.vue가 받고 app.vue가 뿌린다 -->
    
    <!-- ---------------------------------------------------------------------- -->
    
    <!-- 여기엔 메인 내용이 있을 것이다. -->
    
    <!-- ---------------------------------------------------------------------- -->
    
    <Footer />
</template>

```

### Header.vue

```vue

<template>
    <header class="header fixed-header">
        <div>
            <h1 class="header-title"><a href="/index"><img class="logo" src="/image/logo-w.png" alt="알랜드"></a></h1>

            <ul class="main-menu d-none d-inline-flex-sm">
                <li><a class="" href="/menu/list">카페메뉴</a></li>
                <li><a class="" href="/notice/list">공지사항</a></li>
                <li><a class="" href="/user/login">로그인</a></li>
            </ul>
            <div class="d-none-sm"><a class="icon icon-menu icon-white" href="?m=on">메뉴버튼</a></div>
        </div>
    </header>
</template>

```

### Footer.vue

```vue

<template>
    <footer class="footer">
        <h2>알랜드(Rland)</h2>
        <div>
            copyright @ rland.co.kr 2022-2022 All Right Reservved. Contact admin@rland.co.kr for more information
        </div>
    </footer>
</template>

```

vue.js에서 페이지 간 이동을 위한 라이브러리 Vue Router 사용

web에서 routing은 좀 다르다
라우팅이란 클라이언트에서 url주소에 따라 페이지가 전환되는 것. 서버에서 새로 가져오지 않음

router-view
	페이지 표시 태그
	url에 따른 컴포넌트가 화면에 그려지는 영역
	
router-link to="경로"

컴파일 시, <a> 태그로 변환
to 속성
to 속성 값의 경로로 이동
v-bind와 함께 사용하면 동적으로 경로를 만들 수 있음
to="test/path" 처럼 붙이면 현재 url에 이 path가 붙고,
to="/test/detail" 처럼 붙이면 default url에 붙음 (대표적)
styling : router-link-exact-active 등 class를 통해 스타일을 줄 수 있음

router-link를 안쓰고 a를 쓰면 개발서버에서 링크를 클릭 했을 때 url이 #/로 끝난다.
<router-link :to="'detail?id=' + m.id">

--

```vue

import App from './App.vue';
import { createApp } from 'vue';
import { createRouter, createWebHashHistory } from 'vue-router';

import Layout from './components/Layout.vue';
import Index from './components/Index.vue';
import List from './components/menu/List.vue';
import Detail from './components/menu/Detail.vue';
import About from './components/About.vue';


import AdminLayout from './components/admin/Layout.vue';
import AdminMenuList from './components/admin/menu/List.vue';

const routes = [
    {
        path: '/index', component: Index
    },
    {
        path: '/', component: Layout, children: [
            { path: 'menu/list', component: List },
            { path: 'menu/:id', component: Detail },
            { path: 'about', component: About }
            // children에 들어온 .vue들은 Layout을 공유한다.
        ]
    },
    {
        path: '/admin', component: AdminLayout, children: [
            { path: 'menu/list', component: AdminMenuList }
            // children의 path를 시작할 때 /로 시작하면 admin을 무시해버린다 하지만 컴포넌트는 상속받는다
            // /admin이 루트다 따라서 /admin이 경로로 사용된다면 잘못된 것
            // 만약 /admin 에서 링크 menu/list를 클릭하면 /admin/menu/list 로 가지 않고 /menu/list 로 간다
        ]
    }
]
// 해당 예제에선 일반 index page와 admin의 index page의 layout이 다르다고 가정 
// App.vue에서 router-view는 layout 혹은 AdminLayout을 가져온다

// url 요청에 따라 응답하는 Layout이 다르다
// 사용자가 '/'를 요청하면 App.vue의 router-view를 통해 ./components/Layout.vue를 보여준다
// http://localhost:5173/#/index 에서 url에 뜨는 #은 개발중인 root라는 의미?

// children(자식) - 앞에 있는 url을 이어 받는다
// 여기서 router-view는 2개다. '/' 와 '/admin/index' 갈 때 1개
// Layout이 router-view 가지고 있어 Index와 About을 갈 때 1개

const router = createRouter({
    // 4. Provide the history implementation to use. We are using the hash history for simplicity here.
    history: createWebHashHistory(),
    routes, // short for `routes: routes`
})

createApp(App)
    .use(router)
    .mount("#app")

    // createApp은 MVC를 지원하는 함수. 라이브러리
    // createApp, use , mount는 app을 반환하므로 바로 .으로 쓴 것
    // 지시서다?
    // mount는 view에 모델 전달
    
```


--
스타일 스코프

```css
<style scoped>
.header {
    position: fixed;
}
/* Header를 갖고 있으므로 style을 줘도 괜찮다 */

/* layout과 menu/list는 포함관계 지만 /index와 menu/list는 포함관계가 아님에도 style이 공유되고 있다 */
/* components안에 있는 모든 style을 공유하기 때문? scoped를 설정해줘야 한다. */
/* scoped - 이름 충돌 X, 개발자 도구로 열어보면 style에 식별자가 붙는다 */
</style>

<!-- scoped를 안 쓰면 모든 .vue 페이지 에서 스타일이 적용되긴 하나, 따로두는 이유는 Index.vue를 볼 때는 위의 css가 필요 없기 때문이다. 성능? -->
```

--

상품에 맞는 detail 페이지 표시하기

1. query에서 id값 가져오기

링크 거는 방법
<router-link :to="'detail?id=' + m.id"></router-link>

쿼리스트링에서 값 져오는 방법
${this.$route.query.id}

```js
<script>
export default {
    data() {
        return { menu: null }
    },
    beforeCreate() {
        fetch(`http://localhost:8080/menus/${this.$route.query.id}`)
            .then(res => res.json())
            .then(result => this.menu = result)
    },
    created() {
        console.log(`created : ${this.menu}`);
    },
    beforeMount() {
        console.log(`beforeMount : ${this.menu}`);
    },
    mounted() {
        console.log(`mounted : ${this.menu}`);
    },
    updated() {
        console.log(`updated : ${this.menu}`);
    }

}
</script>
```

위와 같이 쿼리 값에서 id를 가져오고 그 id를 이용해 다시 데이터를 요청해서 view에서 사용하려 한다.

그럼 화면이 뜨기 전 단계에서 데이터 요청 한다면?
원하는 화면이 나오지만 콘솔에 에러가 뜬다.
beforeCreate menu는 undefined - 아직 data()도 만들어지지 않았다.
그 후 단계 created, beforeMount, mounted에선 menu가 null이고 페이지는 안 뜰 것이다

하지만 mounted 단계 전에 데이터를 빨리 받아온다면 menu가 null이라는 에러가 콘솔에 뜬 상태로 원하는 페이지가 보여질 것이다.

페이지가 보이기 전 단계(mounted)에서 데이터를 요청하는 것은 바람직 하지 않고 이후 menu가 null이 아닐 때 화면을 update하는 게 바람직 하다

해결 방법 - v-if를 하여 menu가 null이 아닐 때 update를 하여 화면을 갱신 해야 한다.

v-if는 안 보일땐 처리자체를 안한다

v-show 보이든 안 보이든 처리한다. d-none를 하는듯?

v-bind, css 와 같은 것은 화면에 보여졌을 때 효과를 줄 수 있는 것이다.


2. url 경로에서 가져오기

링크 거는 방법
<router-link :to="'./' + m.id"></router-link>

url 경로에서 값 가져오는 방법
${this.$route.params.id}

url경로가 바뀌었으므로 vue router의 path도 다음과 같이 수정해야 한다
path: 'menu/:id'
이것은 menu/ 뒤에 붙은 url을 id라는 이름으로 쓴다는 것.
url 경로에서 값을 가져올 때 ${this.$route.params.id} 마지막 .id쓴 이유가 이것이다.



--

서버에 데이텨 요청과 CORS 방법

```js
<script>
import NewMenuList from './NewMenuList.vue';


export default {
    data() {
        return {
            list: [{}, {}, {}],
            newList: []
        };
    },
    mounted() {
        fetch("http://localhost:8080/menus")
            .then((response) => response.json())
            .then(data => {
                this.list = data.list;
                this.newList = data.newList;
            });
        // 첫 번째 then에서 response.json()을 {}로 감싸고 return을 생략한다면 다음 then은 return 받는게 없다? 확인필요
        // 두 번째 화살표 함수에서 {}를 안쓰면 this.list = list를 return한다는 의미이다. 하지만 {}를 생략해줘도 된다.
        // 사용자가 서버(origin) 문서(single page)를 요청하고 그 후 데이터를 요청한다. 요청하는 origin이 같다.
        // 문서를 요청하는 서버와 데이터를 요청하는 서버가 다를 수 있다. cross origin
        // 현재는 다른 origin을 갖고 있는 사용자에게 데이터를 줄지 말지는 서버가 정한다
        // 서버 허용 방법 spring에서 class, method 등 에 @CrossOrigin(origins = "http://localhost:5173/")
        // spring에서 - global하게 설정하는 방법
        // @Bean
        // public WebMvcConfigurer corsConfigurer() {
        //     return new WebMvcConfigurer() {
        //         @Override
        //         public void addCorsMappings(CorsRegistry registry) {
        //             registry.addMapping("/**").allowedOrigins("http://localhost:5173/");
        //         }
        //     };
        // }
        // /*은 루트 바로 아래만 /**은 루트 아래 아래 아래 ... 포함
        // 참고 링크 https://spring.io/guides/gs/rest-service-cors/#controller-method-cors-configuration
    },
    components: { NewMenuList }
}

</script>
```
