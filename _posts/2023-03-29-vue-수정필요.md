---
title: Vue.js
tags: Vue javascript
---

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="./calc2.js" defer="defer"></script>
</head>
<body>
	<h1>{{x}}</h1>
</body>
</html>
```

Vue를 사용하려면 html에서 script 태그 추가가 필요하다

```js
// calc.js
Vue
	.createApp({
		data() {
			let x = 30;
			let y = 40;

			return { x, y };
		}
	.mount("#calc");
```

Vue 2.0에서는 new Vue로 객체를 만들었다. Vue 3.0에선 메소드를 통해 만든다

createApp이라는 Vue의 메소드에 {} 객체를 인수로 준 것이다. 해당 객체에 data()란 함수? (속성,옵션 Options API, 키)이 존재하는 것, 값으로 x, y가 있는 것이다.

data는 들어갈 값이 function이라 ()를 붙여준 것

data(){}영역은 데이터를 뿌리기 위한 공간?? vue의 예약어??
return을 이용해 모델을 리턴한다. 값을 객체에 담아(가장큰 {}) 모델로 html에 전달한다.
 #calc에 뿌린다. Vue의 메소드 mount이용
결국 h1태그안에 x의 값 30이 들어간다

methods가 Controller / data는 Model / html이 View다

-------------------------------

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="./calc2.js" defer="defer"></script>
</head>
<body>
	<section id="calc">
		<h1>덧셈 계산기{{x}}</h1>
		<form>
			<fieldset>
				<legend>계산기 입력폼</legend>
				<div>
					<label>x:</label> <input dir="rtl" value="0">
					<label>y:</label> <input dir="rtl" value="0"> <span>=</span>
					<span>0</span>
				</div>
				<hr>
				<div>
					<input type="submit" value="초기화" v-on:click="resetHandler">
					<input type="submit" value="계산하기" v-on:click="calcHandler">
				</div>
			</fieldset>
		</form>
	</section>
</body>
</html>
```

```js
Vue
	.createApp({
		data() {
			let x = 30;
			let y = 40;

			return { x, y };
		},
		methods: {
			calcHandler(e) {
				e.preventDefault();
				console.log("calc");
			},
			resetHandler(e) {
				e.preventDefault();
				console.log("reset");
			}
		}
	})
	.mount("#calc");
```

createApp에 객체를 인수로 줬고 그 객체에는 data() 함수와 method 객체? 속성?이 존재하고 해당 method 객체? 속성?에 함수 2개가 존재하는 것이다. 
methods: 는 메소드 객체 만드는 공간??
html에서 type이 summit인 input에 각각 클릭했을 때 실행될 메소드를 연결했다.
하지만 summit이 되면 페이지가 새로고침 되므로 e.preventDefault();를 해도 되지만 다음과 같이 Vue를 통해 해결할 수 도 있다

```html
<input type="submit" value="초기화" v-on:click.prevent="resetHandler">
<input type="submit" value="계산하기" v-on:click.prevent="calcHandler">
```
click 뒤에 .prevent를 이용하면 e.preventDefault();와 같은 효과를 얻을 수 있다.


--------------------------------


```html
<input dir="rtl" v-bind:value="x">
<input dir="rtl" v-bind:value="y">
```

위 html에서 기본 value는 0 이지만 Vue의 data에서 return한 x y를 input의 기본 value로 설정할 수 있다.
원래 input에 있었던 value="0"을 안 지우고 <input dir="rtl" value="0" v-bind:value="y">와 같이 vue와 공존하게 되면
thymeleaf처럼 대체되는 것이 아닌 0이 나왔다.

--------------------------------------


v-on은 다음과 같이 축약해서 쓸 수 있다

```html
<input type="submit" value="초기화" @click.prevent="resetHandler">
<input type="submit" value="계산하기" @click.prevent="calcHandler">
```

v-bind는 다음과 같이 축약해서 쓸 수 있다

```html
<label>x:</label>
<input dir="rtl" :value="x">
<label>y:</label>
<input dir="rtl" :value="y">
```

v-text는 Element의 텍스트 콘텐츠를 업데이트한다. thymeleaf처럼 기존값이 있어도 오버라이드 한다.

```html
<span v-text="z">0</span>
```

v-model 양식 입력 요소 또는 구성 요소에서 양방향 바인딩을 만듭니다. 적용하면 필드값 양방향 영향.
input에서 x값을 바꾸면 h1안에있는 {{x}}의 값도 바뀐다

```html
<input dir="rtl" v-model="x">
<input dir="rtl" v-model="y">
```

@input on.input을 추가하여 text가 수정될 때마다 calcHandler메소드 실행

```html
<input dir="rtl" v-model="x" @input="calcHandler">
<input dir="rtl" v-model="y" @input="calcHandler">
```

js에서 계산기능 구현 this가 필요하다

```js
calcHandler(e) {
	this.z = this.x + this.y
}
```

하지만 30 + 40이 문자열 더하기로 되므로 결과는 3040이 된다. parseInt가 필요하다.

js에서 하는 방법

```js
calcHandler(e) {
	this.z = parseInt(this.x) + parseInt(this.y);
}
```

html에서 vue를 이용하는 방법
.trim.number를 이용한다

```html
<input dir="rtl" v-model.trim.number="x" @input="calcHandler"> 
<input dir="rtl" v-model.trim.number="y" @input="calcHandler">
```

---------------------------------------

```js
Vue
	.createApp({
		methods:{
			categoryClickHandler(e){
				this.load(e.target.dataset.id);
				console.log("click")
			},
			load(cid){
				console.log("load");
			}
		}

	})
	.mount("#main-section");
```
	
클릭 했을 때 load 메소드가 실행된다. this가 꼭 필요하다.
console.log의 출력순서는 load 후에 click이다

---------------------------------------------

XHR - callback을 이용한 비동기처리. 콜백함수의 중첩이 심해졌다
fetch - promise를 이용한 비동기처리

```js
Vue
	.createApp({
		methods:{
			categoryClickHandler(e){
				console.log("click");
				this.load(e.target.dataset.id);
				console.log("데이터가 도착 후 할일")
			},
			load(cid){
				setTimeout( () =>{
					console.log("데이터 로드 완료");
				}, 3000);
			}
		}
	})
```
	
클릭으로 데이터를 요청하고 그 요청이 도착하면 할일이 있다고 가정하자.
하지만 데이터 로드는 3초의 시간이 걸린다고 하자.
위와 갈이 한다면 console.log의 출력순서는 click → 데이터가 도착 후 할일 → 데이터 로드 완료
setTimeout은 기본적으로 비동기처리로. load 함수를 기다리는 3초동안 다른 걸 할 수 있으며, 데이터가 올 때까지 기다리지 않고 다음 코드를 실행한다.


```js
console.log("click");
let data = load(2, function(data){
    console.log("도착한 데이터 :" + data.name)
});

function load(cid, callback){

  setTimeout(()=>{
    console.log("데이터가 도착하였습니다.")
    callback({name:"홍길동"});
  },2000);

}
```
위와 똑같은 js 코드



-----------------------------------

```js
Vue
	.createApp({
		methods:{
			categoryClickHandler(e){
				this.load(e.target.dataset.id, function(){
					console.log("데이터가 도착 후 할일")
				});
				console.log("click");
			},
			load(cid, callback){
				
				setTimeout( () =>{
					console.log("데이터 로드 완료");
					callback();
				}, 3000);
			}
		}
	})
```
	
콜백함수로 위 문제를 해결한다면 다음과 같다.
console.log의 출력순서는 click → 데이터 로드 완료 → 데이터가 도착 후 할일 

-------------------------------------------


```js
		methods: {
			async categoryClickHandler(e) {
				console.log("click");
				await this.load(e.target.dataset.id);
				console.log("데이터가 도착 후 할일")
			},
			load(cid) {
				return new Promise(resolve => {
					setTimeout(() => {
						console.log("데이터 로드 완료");
						resolve();
					}, 3000);
				});
			}
		}
```
		
resolve(); 가 없다면 awiat에서 멈춘다. promise가 처리될 때 까지 기다리기 떄문?
		
		
```js
		methods: {
			async categoryClickHandler(e) {
				console.log("click");
				
				let response = await fetch("/menus");
				console.log(response);
				
				let list = await response.json();
				console.log(list);
				
				console.log("데이터가 도착 후 할일");
			}
		}
```
		
fetch는 send 요청과 같다. 비동기함수.
비동기로 처리된녀석이 데이터가 도착했을 때(Response 했을때)까지 처리된 다음에 다음 코드가 실행되어야 한다면 
await를 사용해야 한다. await가 동기형으로 바꿔줌

await가 없다면 Promise가 변수에 저장된다.
promise가 응답할 때 까지 기다리는게 await
		
.json()은 promise를 반환한다
위와 같이 쓰는걸 선생님은 선호한다
		
		
```js
		methods: {
			categoryClickHandler(e) {
				this.load(2);
			},
			load(cid) {

				fetch("/menus", function(response) {/*결과 후에 실행할 코드*/ });
				// 이건 그냥 예시? 안되는 방식이다?

				let promise = fetch("/menus");
				console.log(promise); // 출력 결과 promise

				promise.then(res => {
					console.log(res); // 출력 결과 response
					
					let promise = res.json();

					promise.then(list => {
						console.log(list); // 원하는 결과 나옴
					});
				});
			}
		}
```
		
than은 비동기 처리가 끝나고 다음으로 실행될 코드다
이것은 콜백에서 없애고자했던 비동기처리의 중첩이 나타난다	

```js
		methods: {
			categoryClickHandler(e) {
				this.load(2);
			},
			load(cid) {

				let promise = fetch("/menus");

				promise.then(res => {
					return res.json();
				})
					.then(list => {
						console.log(list); // 원하는 결과 나옴
						return list;
					})
					

			}
		}

```

then은 앞에 than의 return값을 이용한다

```js
methods: {
			categoryClickHandler(e) {
				this.load(2);
			},
			load(cid) {

				let promise = fetch("/menus1");

				promise.then(res => {
					return res.json();
				})
					.then(list => {
						console.log(list); // 원하는 결과 나옴
						return list;
					})
					.catch(err => {
						console.log(err);
					})

			}
		}
```

```js
methods: {
			categoryClickHandler(e) {
				this.load(2);
			},
			load(cid) {

				let promise = fetch("/menus");

				promise.then(res => {
					return res.json();
				})
					.then(list => {
						return list[999];
					})
					.then(menu => {
						return menu.name;
					})
					.catch(err => {
						console.log("aaaaa");
						console.log("gd");
					})
			}
		}
```

catch는 then에서 에러가나면 바로 순서에 상관없이 catch로 간다
list배열은 10개까지 있다. 하지만 없는 999번째의 name을 요청해서 catch로 갔다.
list배열은 10개까지 있지만 return list[999]는 에러가 나지 않고 undefind가 뜬다. js의 특징?

--

```js
(async () => {console.log("click");

let data = await load(2);

console.log("도착한 데이터 :" + data.name);
})();

function load(cid) {
    return new Promise( resolve => {
        setTimeout(() => {
            console.log("데이터가 도착하였습니다.")
            resolve({name:"hello"});
        }, 2000);
    });
}
```

promise로 처리하면 위와 같다.
function 앞에 async를 붙이면 해당 함수는 항상 프라미스를 반환합니다.

자바스크립트는 await 키워드를 만나면 프라미스가 처리될 때까지 기다립니다. 동기처리
await는 async 함수 안에서만 동작합니다.

해당 예제에서는 이름이 없는 함수에 async를 썻다.
함수는 정의 된 다음에 실행될 수 있으므로 크게 ()로 감싸주고 실행()했다.

promise를 return 한다.

위 코드에서 resolve가 없다면 await에서 멈춰 "데이터가 도착하였습니다."까지 출력되고 다음 콘솔.log인 "도착한 데이터"가 출력안된다

위 코드에서 await가 없이 hello를 뽑고 싶다면 다음과 같이 than을 써야한다

```js
let data = load(2);

data.then(aa=>{
    console.log(aa.name);   
})
```