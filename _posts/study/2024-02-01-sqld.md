---
title: SQLD
tags: db
---

## 데이터 모델링의 이해

### 엔터티(Entity) = 테이블

* 업무에서 필요하고, 관리하고자 하는 정보 (e.g 환자, 직원)

* 인스턴스(Instance) '두 개'이상의 집합이다.

### 인스턴스(Instance) = 행(Row)

* 데이터 전체 집합(한 줄)

<br/>

### 속성(Attribute) = 컬럼(Column)

* 인스턴스에서 최소 데이터 단위

* 한 개의 속성은 한 개의 속성값을 갖는다.

* 속성명은 전체 DB에서 유일하게 하는 것이 좋다.

<br/>

### 파생속성

    * 조회시 빠른 성능을 위해 원래 속성의 값을 계산하여 저장한 속성

<br/>

* 도메인(Domain)

    * 속성이 가질 수 있는 값의 범위.

    * 데이터타입과 크기, 제약사항을 지정한다.

<br/>

* 엔터티 관계 연결

    * 두 개의 엔터티 사이에 '관심 있는 연관규칙', '정보의 조합', 관계연결 규칙', '동사' 있어야 한다.

<br/>

* 식별자

    * 주식별자(Primary Identifier)

        * 유일성 - 인스턴스 내 유일
        
        * 최소성 - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수여야 한다

        * 불변성 - 식별자 값이 변하면 안됨

        * 존재성 - Null 안됨

    * 보조식별자(Alternate Identifier)

    * 외부식별자(Foreign Identifier)

    * 단일식별자(Single Identifier)

    * 복합식별자(Composit Identifier)

    * 인조식별자

        * 일렬번호와 같이 새로만든 식별자

<br/>

* 식별자관계, 비식별자관계

    * 식별자관계

        * 강한 연결관계

        * 자식 주식별자의 구성에 포함

        * 관계 표현 시 '실선' 표현

        * 상속받은 주식별자속성을 타 엔터티(손자)에 '이전' 필요

    * 비식별자관계

        * 약한 연결관계

        * 자식 일반 속성에 포함

        * 관계 표현 시 '점선' 표현

        * 상속받은 주식별자속성을 타 엔터티(손자)에 '차단' 필요

## 데이터 모델과 성능

* 반졍규화

    * 성능 향상을 위해 데이터 중복

    * 디스크 I/O량이 많거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상될 때 수행

<br/>

* 파티셔닝(Partitioning)

    * 대량의 데이터를 PK의 성격에 따라 부분적인 테이블로 분리하는 기법

<br/>

* 성능

    * Join을 최소화 할수록 성능이 좋아진다.

    * 한 테이블에 칼럼이 많다면 디스크 I/O가 많아진다. 트랜잭션이 접근하는 칼럼유형을 분석하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어들어 조회 성능을 향상 시킬 수 있다.

    * DB 조회 시 SQL문 Where절의 '='으로 조회되는 칼럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장 높다

    * 엔터티 간의 관계를 정의하여 관련 엔터티 상호간에 업무적인 연관성이 있을 경우 Join이 자주 발생한다는 것을 의미하므로 FK Constranints를 생성했는지 여부에 상관없이 Join 성능을 향상시키기 위해 FK에 인덱스를 생성해주는 것이 좋다.

<br/>

* GSI(Global Single Instance)

    * 통합데이터베이스, 한 개의 인스턴스

## SQL 기본

* TCL(Transaction Control Language)

    * COMMIT, ROLLBACk

    * 일부에서는 DCL로 분류

<br/>

* 제약조건

    * UNIQUE - NULL 가능

    * PK - 테이블 당 1개, UNIQUE + NOT NULL

    * FK - NULL 가능

<br/>

* SQL Server와 Oracle

    * SQL Server는 ALTER로 컬럼명 수정 시 한 번에 여러 컬럼을 수정할 수 없으며, 괄호를 사용하지 않는다.

    * SQL Server는 컬럼을 수정할 때 NOT NULL을 지정하지 않으면, 기존 제약조건의 NOT NULL이 NULL로 변경된다. Oracle도 이러는지는 모르겠다...

    * DB에 INSERT로 '' 입력 시

        * Oracle은 NULL로 입력되며 조건절에서는 컬럼 IS NULL로 조회

        * SQL Server는 ''로 입력되며 조건절에서는 컬럼 = ''로 조회

    * DDL 수행 후

        * Oracle은 자동 COMMIT 및 내부적으로 트랜젝션을 종료시킨다

        * SQL Server는 COMMIT을 수행하지 않으며 트랙젝션도 종료되지 않는다

    * Oracle은 SELECT절에 기술되지 않은 컬럼명으로도 ORDER BY 정렬 가능. 단, GROUP BY를 사용 시 ORDER BY에 GROUP BY로 묶지않은 값, 집계함수로 묶지 않은 값은 사용할 수 없으니 주의

<br/>

* 삭제

    * DROP

        * DDL

        * Rollback 불가능, Auto Commit

        * 테이블이 사용했던 Storage를 모두 Release

        * 테이블 정의 자체를 완전히 삭제

        * 로그 안남음

    * TRUNCATE

        * DDL, 일부 DML 성격 가짐

        * Rollback 불가능, Auto Commit

        * 테이블이 사용했던 Storage 중 최초 테이블 생성시 할당된 Storage(스키마 정의)만 남기고 Release

        * 테이블을 최초 생성된 초기상태로 만듬

        * 로그 안남음

    * DELETE

        * DML

        * Commit 이전 Rollback 가능, 사용자 Commit

        * 데이터를 모두 Delete해도 사용했던 Storage는 Release되지 않음

        * 데이터만 삭제

        * 로그 남음

<br/>

* BEGIN TRANSACTION

    * COMMIT TRANSACTION 혹은 ROLLBACK TRANSACTION 으로 트랜젝션 종료. TRANSACTION 생략하고 COMMIT, ROLLBACK 가능

    * SAVE TRANSACTION

        * 트랙젝션의 일부만 ROLLBACK 할 수 있다

            * Oracle

                ```sql
                SAVEPOINT SP1;

                ...

                ROLLBACK TO SP1;
                ```

            * SQL Server

                ```sql
                SAVE TRANSACTION ST1;

                ...

                ROLLBACK TRANSACTION ST1;
                ```

<br/>

* 논리연산자 우선순위

    * NOT → AND → OR

<br/>

* NULL

    * NULL은 0과 공백과는 다른 값

    * 4칙 연산에 NULL을 포함한 결과는 NULL

    * 함수에서 NULL은 연산에서 제외되는 듯 하다.

        * e.g AVG(20, 0, NULL)은 10이다.

<br/>

* SEARCHED_CASE_EXPRESSION

    ```sql
    SELECT
        CASE WHEN 컬럼 = '조건' THEN '참'
            ELSE '거짓'
        END
    FROM DEPT;
    ```

* SIMPLE_CASE_EXPRESSION

    ```sql
    SELECT
        CASE 컬럼 WHEN '조건' THEN '참'
            ELSE '거짓'
        END
    FROM DEPT;
    ```

<br/>


* 내장 함수(Built-in Function)

    * 단일행 함수(Single-Row Funtion)

        * 문자형 함수

            * LOWER, UPPER, LENGTH/LEN 등...
        
        * 숫자형 함수

            * ABS, MOD, ROUND 등...

        * 날짜형 함수

            SYSDATE/GETDATE, EXTRACT/DATEPART 등...

        * 변환형 함수

            * TO_NUMBER, TO_CHAR, TO_DATE 등...

        * NULL관련 함수

            * NVL/ISNULL() - 첫 번째 인자가 NULL일경우 두 번째 인자로 대체. 조건절의 IS NULL과 착각하지 말자

            * NULLIF() - 첫 번째 인자와 두 번째 인자가 같으면 NULL로 대체

            * COALESCE() - 인자'별'로 NULL이 아닌 첫번째 값을 나타냄. 즉 인자를 3개 넣으면 3개의 값이 나온다. 모든 값이 NULL이라면 NULL 반환

    * 다중행 함수(Multi-Row Function)

        * 집계 함수(Aggregate Funtion)

            * COUNT, SUM, AVG, MAX, MIN, STDDEV, VARIAN, 기타 통계 함수

        * 그룹 함수(Group Function)

        * 윈도우 함수(Window Function)

    * 단일행 함수, 다중행 함수 동일하게 단일 값만을 반환한다.

    * 1:M Join이라도 M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로 M 쪽에서도 단일행 함수 사용할 수 있다

