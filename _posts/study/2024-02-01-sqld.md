---
title: SQLD
tags: db
---

## 데이터 모델링의 이해

### 엔터티(Entity) = 테이블

* 업무에서 필요하고, 관리하고자 하는 정보 (e.g 환자, 직원)

* 인스턴스(Instance) '두 개'이상의 집합이다.

### 인스턴스(Instance) = 행(Row)

* 데이터 전체 집합(한 줄)

### 속성(Attribute) = 컬럼(Column)

* 인스턴스에서 최소 데이터 단위

* 한 개의 속성은 한 개의 속성값을 갖는다.

* 속성명은 전체 DB에서 유일하게 하는 것이 좋다.

* 파생속성

    * 조회시 빠른 성능을 위해 원래 속성의 값을 계산하여 저장한 속성

### 도메인(Domain)

* 속성이 가질 수 있는 값의 범위.

* 데이터타입과 크기, 제약사항을 지정한다.

### 엔터티 관계 연결

* 두 개의 엔터티 사이에 '관심 있는 연관규칙', '정보의 조합', 관계연결 규칙', '동사' 있어야 한다.

### 식별자

* 주식별자(Primary Identifier)

    * 유일성 - 인스턴스 내 유일

    * 최소성 - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수여야 한다

    * 불변성 - 식별자 값이 변하면 안됨

    * 존재성 - Null 안됨

* 보조식별자(Alternate Identifier)

* 외부식별자(Foreign Identifier)

* 단일식별자(Single Identifier)

* 복합식별자(Composit Identifier)

* 인조식별자

    * 일렬번호와 같이 새로만든 식별자

### 식별자관계, 비식별자관계

* 식별자관계

    * 강한 연결관계

    * 자식 주식별자의 구성에 포함

    * 관계 표현 시 '실선' 표현

    * 상속받은 주식별자속성을 타 엔터티(손자)에 '이전' 필요

* 비식별자관계

    * 약한 연결관계

    * 자식 일반 속성에 포함

    * 관계 표현 시 '점선' 표현

    * 상속받은 주식별자속성을 타 엔터티(손자)에 '차단' 필요

## 데이터 모델과 성능

### 반졍규화

* 성능 향상을 위해 데이터 중복

* 디스크 I/O량이 많거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상될 때 수행

### 파티셔닝(Partitioning)

* 대량의 데이터를 PK의 성격에 따라 부분적인 테이블로 분리하는 기법

### 성능 향상 방법

* Join을 최소화 할수록 성능이 좋아진다.

* 한 테이블에 칼럼이 많다면 디스크 I/O가 많아진다. 트랜잭션이 접근하는 칼럼유형을 분석하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어들어 조회 성능을 향상 시킬 수 있다.

* DB 조회 시 SQL문 Where절의 '='으로 조회되는 칼럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장 높다

* 엔터티 간의 관계를 정의하여 관련 엔터티 상호간에 업무적인 연관성이 있을 경우 Join이 자주 발생한다는 것을 의미하므로 FK Constranints를 생성했는지 여부에 상관없이 Join 성능을 향상시키기 위해 FK에 인덱스를 생성해주는 것이 좋다.

### GSI(Global Single Instance)

* 통합데이터베이스, 한 개의 인스턴스

## SQL 기본

### TCL(Transaction Control Language)

* COMMIT, ROLLBACk

* 일부에서는 DCL로 분류

### 제약조건

* UNIQUE - NULL 가능

* PK - 테이블 당 1개, UNIQUE + NOT NULL

* FK - NULL 가능

### Oracle과 SQL Server

* SQL Server는 ALTER로 컬럼명 수정 시 한 번에 여러 컬럼을 수정할 수 없으며, 괄호를 사용하지 않는다.

* SQL Server는 컬럼을 수정할 때 NOT NULL을 지정하지 않으면, 기존 제약조건의 NOT NULL이 NULL로 변경된다. Oracle도 이러는지는 모르겠다...

* DB에 INSERT로 '' 입력 시

    * Oracle은 NULL로 입력되며 조건절에서는 컬럼 IS NULL로 조회

    * SQL Server는 ''로 입력되며 조건절에서는 컬럼 = ''로 조회

* DDL 수행 후

    * Oracle은 자동 COMMIT 및 내부적으로 트랜젝션을 종료시킨다

    * SQL Server는 COMMIT을 수행하지 않으며 트랙젝션도 종료되지 않는다

* Oracle은 SELECT절에 기술되지 않은 컬럼명으로도 ORDER BY 정렬 가능. 단, GROUP BY를 사용 시 ORDER BY에 GROUP BY로 묶지않은 값, 집계함수로 묶지 않은 값은 사용할 수 없으니 주의

### DROP TRUNCATE DELETE

* DROP

    * DDL

    * Rollback 불가능, Auto Commit

    * 테이블이 사용했던 Storage를 모두 Release

    * 테이블 정의 자체를 완전히 삭제

    * 로그 안남음

* TRUNCATE

    * DDL, 일부 DML 성격 가짐

    * Rollback 불가능, Auto Commit

    * 테이블이 사용했던 Storage 중 최초 테이블 생성시 할당된 Storage(스키마 정의)만 남기고 Release

    * 테이블을 최초 생성된 초기상태로 만듬

    * 로그 안남음

* DELETE

    * DML

    * Commit 이전 Rollback 가능, 사용자 Commit

    * 데이터를 모두 Delete해도 사용했던 Storage는 Release되지 않음

    * 데이터만 삭제

    * 로그 남음

### BEGIN TRANSACTION

* COMMIT TRANSACTION 혹은 ROLLBACK TRANSACTION 으로 트랜젝션 종료. TRANSACTION 생략하고 COMMIT, ROLLBACK 가능

    * SAVE TRANSACTION

        * 트랙젝션의 일부만 ROLLBACK 할 수 있다

            * Oracle

                ```sql
                SAVEPOINT SP1;

                ...

                ROLLBACK TO SP1;
                ```

            * SQL Server

                ```sql
                SAVE TRANSACTION ST1;

                ...

                ROLLBACK TRANSACTION ST1;
                ```

### 논리연산자 우선순위

* NOT → AND → OR

### NULL

* NULL은 0과 공백과는 다른 값

* 4칙 연산에 NULL을 포함한 결과는 NULL

* 함수에서 NULL은 연산에서 제외되는 듯 하다.

    * e.g AVG(20, 0, NULL)은 10이다.


### SEARCHED_CASE_EXPRESSION

```sql
SELECT
    CASE WHEN 컬럼 = '조건' THEN '참'
        ELSE '거짓'
    END
FROM DEPT;
```

### SIMPLE_CASE_EXPRESSION

```sql
SELECT
    CASE 컬럼 WHEN '조건' THEN '참'
        ELSE '거짓'
    END
FROM DEPT;
```

### 내장 함수(Built-in Function)

* 단일행 함수(Single-Row Funtion)

    * 문자형 함수

        * LOWER, UPPER, LENGTH/LEN 등...

    * 숫자형 함수

        * ABS, MOD, ROUND 등...

    * 날짜형 함수

        * SYSDATE/GETDATE, EXTRACT/DATEPART 등...

    * 변환형 함수

        * TO_NUMBER, TO_CHAR, TO_DATE 등...

    * NULL관련 함수

        * NVL/ISNULL() - 첫 번째 인자가 NULL일경우 두 번째 인자로 대체. 조건절의 IS NULL과 착각하지 말자

        * NULLIF() - 첫 번째 인자와 두 번째 인자가 같으면 NULL로 대체

        * COALESCE() - 인자'별'로 NULL이 아닌 첫번째 값을 나타냄. 즉 인자를 3개 넣으면 3개의 값이 나온다. 모든 값이 NULL이라면 NULL 반환

* 다중행 함수(Multi-Row Function)

    * 집계 함수(Aggregate Funtion)

        * COUNT, SUM, AVG, MAX, MIN, STDDEV, VARIAN, 기타 통계 함수

    * 그룹 함수(Group Function)

    * 윈도우 함수(Window Function)

* etc

    * 단일행 함수, 다중행 함수 동일하게 단일 값만을 반환한다.

    * 1:M Join이라도 M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로 M 쪽에서도 단일행 함수 사용할 수 있다

### EQUI JOIN

```sql
SELECT 테이블1.컬럼, 테이블2.컬럼
FROM 테이블1, 테이블2
WHERE 테이블1.컬럼 = 테이블2.컬럼;
```

WHERE절에 JOIN 조건을 넣는다.

### ANSI/ISO SQL 표준 EQUI JOIN

```sql
SELECT 테이블1.컬럼, 테이블2.컬럼
FROM 테이블1 INNER JOIN 테이블2
ON 테이블1.컬럼 = 테이블2.컬럼;
```

ON절에 JOIN 조건을 넣는다.

## SQL 활용

### 순수 관계 연산자

* SELECT - WHERE 절로 구현

* PROJECT - SELECT 절로 구현

* (NATURAL) JOIN - 다양한 JOIN 기능으로 구현

* DIVIDE - 현재 사용 안함

### ANSI/ISO SQL에서 FROM 절의 JOIN

* INNER JOIN

* OUTER JOIN

* CROSS JOIN

    * JOIN 조건이 없는 경우 모든 데이터 조합. 결과는 M*N. 즉, Cartesian product

* NATURAL JOIN

    * 두 테이블에 둘 다 존재하는 동일한 컬럼을 기반으로 암묵적인 JOIN을 수행. 조인에 이용되는 컬럼은 명시하지 않아도 자동으로 조인에 사용됨

    * 반드시 두 테이블 간에 동일 이름, 타입을 가진 컬럼 필요

    ```sql
    SELECT 컬럼
    FROM 테이블1
    NATURAL JOIN 테이블2
    ```

    * EQUI JOIN에서 JOIN 칼럼에 대해서는 별칭(Alias)이나 테이블 이름과 같은 접두사 불가능. SELECT절 등.. 모든 절에서 사용할 수 없다

* USING 조건절

    * 테이블간에 동일한 이름과 형식의 컬럼이 둘 이상인 경우 USING을 사용하자

    * USING 절은 조인에 사용될 컬럼을 지정

    ```sql
    SELECT 컬럼
    FROM 테이블1
    JOIN 테이블2 USING(조인 컬럼);
    ```

    * EQUI JOIN에서 JOIN 칼럼에 대해서는 별칭(Alias)이나 테이블 이름과 같은 접두사 불가능. SELECT절 등.. 모든 절에서 사용할 수 없다

* ON 조건절

    * ON절에 조건 넣으면 출력은 하되 조건에 맞지 않는 컬럼들은 NULL로 표현된다.

* BETWEEN JOIN은 존재하지 않다.

### 집합 연산자

* UNION

    * 합집합

    * 중복행은 하나로

* UNION ALL

    * 합집합

    * 중복행은 그대로 둔다

* INTERSECT

    * 교집합

    * 중복행은 하나로

* EXCEPT = Oracle은 MINUS

    * 차집합

    * 중복행은 하나로

* INTERSECT, EXCEPT를 대채하는 SQL로 NOT IN, NOT EXISTS 자주 출제

### ORDER BY 1, 2

* 첫 번째 컬럼을 기준으로 정렬한 뒤, 두 번째 컬럼을 기준으로 정렬하라는 의미

### 계층형 질의(Hierarchical Query)

* START WITH

    * 계층 구조 전개의 시작 위치. 루트 데이터(LEVEL 1)를 지정한다.

    ```sql
    START WITH 컬럼 IS NLL
    START WITH 컬럼 = '100'
    ```

* CONNECT BY PRIOR A = B

    * PRIOR. 즉, 이전 행 A컬럼의 값과 같은 값을 갖고있는 B컬럼을 찾아 연결

* ORDER SIBLINGS BY 컬럼

    * 동일 LEVEL 사이에서 정렬

* CONNECT BY절에 작성된 조건절은 WHERE절과 달리 START WITH 절의 루트 데이터는 결과목록에 포함되며, 이후 LEVEL 부터 필터링 된다.

* Oracle 계층형 질의문에서 PRIOR는 SELECT, WHERE 절에서도 사용 가능

### 서브쿼리

* 반환되는 데이터 형태에 따른 서브쿼리 분류

    * 단일 행 서브쿼리

        * 서브쿼리 결과가 항상 1건 이하

    * 다중 행 서브쿼리

    * 서브쿼리 결과가 여러 건

    * 다중 칼럼 서브쿼리

        * 여러 칼럼 동시 비교 용도

        * 서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼 개수와 위치가 동일해야 한다.

* etc

    * 서브쿼리는 ORDER BY절을 사용하지 못한다. ORDER BY는 SELECT 절에서 오직 한 개만 올 수 있기 때문에 메인쿼리에서 정렬해야 함

    * 단일 행 서브쿼리는 다중 행 비교 연산자(IN, ALL, ANY, SOME, EXISTS)를 사용하지 못하나, 다중 행 서브쿼리는 단일 행 비교 연산자(=, <, <=, >, >=, <>)를 사용할 수 있다

* 스칼라 서브쿼리

    * SELECT 절에 위치한 서브쿼리

    * 1개의 반환값만 존재해야 한다.

* Inline View

    * FROM 절 내에서 사용되는 서브쿼리

    * SQL 실행 시 임시적으로 생기는 View

* Dynamic View

    * 동적 뷰는 미리 정의된 쿼리를 사용하여 생성되는 가상 테이블

    * 뷰를 쿼리할 때마다 저장된 쿼리를 실행하여 최신 결과를 반환

    * 서브쿼리가 아니니 헷갈리지 말자

### GROUP BY 없이 HAVING

* GROUP BY 없이 HAVING을 사용하였다고 SQL 문장 오류가 생기진 않는다.

### 그룹화 함수

* ROLLUP()

    * 계층 구조를 가진 SUB TOTAL을 생성하는 함수

    105 번 부터 시작해라..

    그룹화 함수부터 검색하고 시작해야 할 듯...